{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dashboard","text":""},{"location":"#dashboard","title":"Dashboard","text":"<p>GitHub Pages: https://xjasonlyu.github.io/leetcode</p> <p>Source Code: https://github.com/xjasonlyu/leetcode</p> <p></p> <p>Some Basic Algorithms:</p> <ul> <li>Binary Search Algorithm</li> <li>Merge Sort Algorithm</li> <li>Quicksort Algorithm</li> <li>Kruskal\u2019s Algorithm</li> <li>Breadth First Search (BFS) Algorithm</li> <li>Depth First Search (DFS) Algorithm</li> </ul> <p>This site is powered by Material for MkDocs and GitHub Pages.</p>"},{"location":"1.two-sum/","title":"1. Two Sum","text":"<p>Problem Page: https://leetcode.com/problems/two-sum/</p> <pre><code>#\n# @lc app=leetcode id=1 lang=python3\n#\n# [1] Two Sum\n#\n# https://leetcode.com/problems/two-sum/description/\n#\n# algorithms\n# Easy (49.76%)\n# Likes:    45395\n# Dislikes: 1480\n# Total Accepted:    9.4M\n# Total Submissions: 19M\n# Testcase Example:  '[2,7,11,15]\\n9'\n#\n# Given an array of integers nums\u00a0and an integer target, return indices of the\n# two numbers such that they add up to target.\n#\n# You may assume that each input would have exactly one solution, and you may\n# not use the same element twice.\n#\n# You can return the answer in any order.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [2,7,11,15], target = 9\n# Output: [0,1]\n# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [3,2,4], target = 6\n# Output: [1,2]\n#\n#\n# Example 3:\n#\n#\n# Input: nums = [3,3], target = 6\n# Output: [0,1]\n#\n#\n#\n# Constraints:\n#\n#\n# 2 &lt;= nums.length &lt;= 10^4\n# -10^9 &lt;= nums[i] &lt;= 10^9\n# -10^9 &lt;= target &lt;= 10^9\n# Only one valid answer exists.\n#\n#\n#\n# Follow-up:\u00a0Can you come up with an algorithm that is less than\u00a0O(n^2)\u00a0time\n# complexity?\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n# Double for loop\n#\n# for i, m in enumerate(nums):\n#     if i+1==len(nums):\n#         return\n#     for j, n in enumerate(nums[i+1:]):\n#         if m+n == target:\n#             return i, i+j+1\n# Hash table\nseen = {}\nfor i, value in enumerate(nums):\nremaining = target - nums[i]\nif remaining in seen:\nreturn [i, seen[remaining]]\nseen[value] = i\n# @lc code=end\n</code></pre>","tags":["Array","Hash Table"]},{"location":"14.longest-common-prefix/","title":"14. Longest Common Prefix","text":"<p>Problem Page: https://leetcode.com/problems/longest-common-prefix/</p> <pre><code>#\n# @lc app=leetcode id=14 lang=python3\n#\n# [14] Longest Common Prefix\n#\n# https://leetcode.com/problems/longest-common-prefix/description/\n#\n# algorithms\n# Easy (40.89%)\n# Likes:    13493\n# Dislikes: 3881\n# Total Accepted:    2.3M\n# Total Submissions: 5.7M\n# Testcase Example:  '[\"flower\",\"flow\",\"flight\"]'\n#\n# Write a function to find the longest common prefix string amongst an array of\n# strings.\n#\n# If there is no common prefix, return an empty string \"\".\n#\n#\n# Example 1:\n#\n#\n# Input: strs = [\"flower\",\"flow\",\"flight\"]\n# Output: \"fl\"\n#\n#\n# Example 2:\n#\n#\n# Input: strs = [\"dog\",\"racecar\",\"car\"]\n# Output: \"\"\n# Explanation: There is no common prefix among the input strings.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= strs.length &lt;= 200\n# 0 &lt;= strs[i].length &lt;= 200\n# strs[i] consists of only lowercase English letters.\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef longestCommonPrefix(self, strs: List[str]) -&gt; str:\n# the python way\nans = ''\nfor v in zip(*strs):\nx = v[0]\nfor i in v:\nif x != i:\nreturn ans\nans += x\nreturn ans\n# @lc code=end\n</code></pre>","tags":["String","Trie"]},{"location":"142.linked-list-cycle-ii/","title":"142. Linked List Cycle II","text":"<p>Problem Page: https://leetcode.com/problems/linked-list-cycle-ii/</p> <pre><code>#\n# @lc app=leetcode id=142 lang=python3\n#\n# [142] Linked List Cycle II\n#\n# https://leetcode.com/problems/linked-list-cycle-ii/description/\n#\n# algorithms\n# Medium (48.87%)\n# Likes:    12740\n# Dislikes: 891\n# Total Accepted:    1.2M\n# Total Submissions: 2.3M\n# Testcase Example:  '[3,2,0,-4]\\n1'\n#\n# Given the head of a linked list, return the node where the cycle begins. If\n# there is no cycle, return null.\n#\n# There is a cycle in a linked list if there is some node in the list that can\n# be reached again by continuously following the next pointer. Internally, pos\n# is used to denote the index of the node that tail's next pointer is connected\n# to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as\n# a parameter.\n#\n# Do not modify the linked list.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [3,2,0,-4], pos = 1\n# Output: tail connects to node index 1\n# Explanation: There is a cycle in the linked list, where tail connects to the\n# second node.\n#\n#\n# Example 2:\n#\n#\n# Input: head = [1,2], pos = 0\n# Output: tail connects to node index 0\n# Explanation: There is a cycle in the linked list, where tail connects to the\n# first node.\n#\n#\n# Example 3:\n#\n#\n# Input: head = [1], pos = -1\n# Output: no cycle\n# Explanation: There is no cycle in the linked list.\n#\n#\n#\n# Constraints:\n#\n#\n# The number of the nodes in the list is in the range [0, 10^4].\n# -10^5 &lt;= Node.val &lt;= 10^5\n# pos is -1 or a valid index in the linked-list.\n#\n#\n#\n# Follow up: Can you solve it using O(1) (i.e. constant) memory?\n#\n#\n# @lc code=start\n# Definition for singly-linked list.\n# from typing import Optional\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution:\ndef detectCycle(self, head):\n# Solution by set:\n# v = set()\n# while head:\n#     if head in v:\n#         return head\n#     v.add(head)\n#     head = head.next\n# return\n# solution by fast&amp;slow pointers\nf = s = head\nwhile True:\nfor _ in range(2):\nif not f:\nreturn None\nf = f.next\ns = s.next\nif f == s:\nbreak\ni = head\nj = s\nwhile i != j:\ni = i.next\nj = j.next\nreturn i\n# @lc code=end\n</code></pre>","tags":["Hash Table","Linked List","Two Pointers"]},{"location":"160.intersection-of-two-linked-lists/","title":"160. Intersection of Two Linked Lists","text":"<p>Problem Page: https://leetcode.com/problems/intersection-of-two-linked-lists/</p> <pre><code>#\n# @lc app=leetcode id=160 lang=python3\n#\n# [160] Intersection of Two Linked Lists\n#\n# https://leetcode.com/problems/intersection-of-two-linked-lists/description/\n#\n# algorithms\n# Easy (54.45%)\n# Likes:    14026\n# Dislikes: 1241\n# Total Accepted:    1.4M\n# Total Submissions: 2.5M\n# Testcase Example:  '8\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n2\\n3'\n#\n# Given the heads of two singly linked-lists headA and headB, return the node\n# at which the two lists intersect. If the two linked lists have no\n# intersection at all, return null.\n#\n# For example, the following two linked lists begin to intersect at node c1:\n#\n# The test cases are generated such that there are no cycles anywhere in the\n# entire linked structure.\n#\n# Note that the linked lists must retain their original structure after the\n# function returns.\n#\n# Custom Judge:\n#\n# The inputs to the judge are given as follows (your program is not given these\n# inputs):\n#\n#\n# intersectVal - The value of the node where the intersection occurs. This is 0\n# if there is no intersected node.\n# listA - The first linked list.\n# listB - The second linked list.\n# skipA - The number of nodes to skip ahead in listA (starting from the head)\n# to get to the intersected node.\n# skipB - The number of nodes to skip ahead in listB (starting from the head)\n# to get to the intersected node.\n#\n#\n# The judge will then create the linked structure based on these inputs and\n# pass the two heads, headA and headB to your program. If you correctly return\n# the intersected node, then your solution will be accepted.\n#\n#\n# Example 1:\n#\n#\n# Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA =\n# 2, skipB = 3\n# Output: Intersected at '8'\n# Explanation: The intersected node's value is 8 (note that this must not be 0\n# if the two lists intersect).\n# From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as\n# [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are\n# 3 nodes before the intersected node in B.\n# - Note that the intersected node's value is not 1 because the nodes with\n# value 1 in A and B (2^nd node in A and 3^rd node in B) are different node\n# references. In other words, they point to two different locations in memory,\n# while the nodes with value 8 in A and B (3^rd node in A and 4^th node in B)\n# point to the same location in memory.\n#\n#\n# Example 2:\n#\n#\n# Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3,\n# skipB = 1\n# Output: Intersected at '2'\n# Explanation: The intersected node's value is 2 (note that this must not be 0\n# if the two lists intersect).\n# From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as\n# [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node\n# before the intersected node in B.\n#\n#\n# Example 3:\n#\n#\n# Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n# Output: No intersection\n# Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it\n# reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0,\n# while skipA and skipB can be arbitrary values.\n# Explanation: The two lists do not intersect, so return null.\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes of listA is in the m.\n# The number of nodes of listB is in the n.\n# 1 &lt;= m, n &lt;= 3 * 10^4\n# 1 &lt;= Node.val &lt;= 10^5\n# 0 &lt;= skipA &lt;\u00a0m\n# 0 &lt;= skipB &lt;\u00a0n\n# intersectVal is 0 if listA and listB do not intersect.\n# intersectVal == listA[skipA] == listB[skipB] if listA and listB\n# intersect.\n#\n#\n#\n# Follow up: Could you write a solution that runs in O(m + n) time and use only\n# O(1) memory?\n#\n# @lc code=start\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\ndef __init__(self, x):\nself.val = x\nself.next = None\nclass Solution:\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n# Stack solution:\n# a = []\n# b = []\n# while headA or headB:\n#     if headA:\n#         a.append(headA)\n#         headA = headA.next\n#     if headB:\n#         b.append(headB)\n#         headB = headB.next\n# x = None\n# for _ in range(min(len(a), len(b))):\n#     i = a.pop()\n#     j = b.pop()\n#     if i != j:\n#         break\n#     x = i\n# return x\n# solution 2:\nlA = lB = 0\na, b = headA, headB\nwhile a:\nlA += 1\na = a.next\nwhile b:\nlB += 1\nb = b.next\nfor _ in range(abs(lA-lB)):\nif lA &gt; lB:\nheadA = headA.next\nelse:\nheadB = headB.next\nwhile headA:\nif headA == headB:\nreturn headA\nheadA = headA.next\nheadB = headB.next\nreturn\n# @lc code=end\n</code></pre>","tags":["Hash Table","Linked List","Two Pointers"]},{"location":"165.compare-version-numbers/","title":"165. Compare Version Numbers","text":"<p>Problem Page: https://leetcode.com/problems/compare-version-numbers/</p> <pre><code>#\n# @lc app=leetcode id=165 lang=python3\n#\n# [165] Compare Version Numbers\n#\n# https://leetcode.com/problems/compare-version-numbers/description/\n#\n# algorithms\n# Medium (35.75%)\n# Likes:    1912\n# Dislikes: 2432\n# Total Accepted:    348.5K\n# Total Submissions: 974.2K\n# Testcase Example:  '\"1.01\"\\n\"1.001\"'\n#\n# Given two version numbers,\u00a0version1 and version2, compare them.\n#\n#\n#\n#\n# Version numbers consist of one or more revisions joined by a dot\u00a0'.'. Each\n# revision\u00a0consists of digits\u00a0and may contain leading zeros. Every revision\n# contains at least one character. Revisions are 0-indexed from left to right,\n# with the leftmost revision being revision 0, the next revision being revision\n# 1, and so on. For example\u00a02.5.33\u00a0and\u00a00.1\u00a0are valid version numbers.\n#\n# To compare version numbers, compare their revisions in left-to-right order.\n# Revisions are compared using their\u00a0integer value ignoring any leading zeros.\n# This means that revisions\u00a01\u00a0and\u00a0001\u00a0are considered\u00a0equal. If a version number\n# does not specify a revision at an index, then\u00a0treat the revision as\u00a00. For\n# example, version\u00a01.0 is less than version\u00a01.1\u00a0because their revision 0s are\n# the same, but their revision 1s are\u00a00\u00a0and\u00a01\u00a0respectively, and\u00a00 &lt; 1.\n#\n# Return the following:\n#\n#\n# If version1 &lt; version2, return -1.\n# If version1 &gt; version2, return 1.\n# Otherwise, return 0.\n#\n#\n#\n# Example 1:\n#\n#\n# Input: version1 = \"1.01\", version2 = \"1.001\"\n# Output: 0\n# Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same\n# integer \"1\".\n#\n#\n# Example 2:\n#\n#\n# Input: version1 = \"1.0\", version2 = \"1.0.0\"\n# Output: 0\n# Explanation: version1 does not specify revision 2, which means it is treated\n# as \"0\".\n#\n#\n# Example 3:\n#\n#\n# Input: version1 = \"0.1\", version2 = \"1.1\"\n# Output: -1\n# Explanation: version1's revision 0 is \"0\", while version2's revision 0 is\n# \"1\". 0 &lt; 1, so version1 &lt; version2.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= version1.length, version2.length &lt;= 500\n# version1 and version2\u00a0only contain digits and '.'.\n# version1 and version2\u00a0are valid version numbers.\n# All the given revisions in\u00a0version1 and version2\u00a0can be stored in\u00a0a\u00a032-bit\n# integer.\n#\n#\n#\n# @lc code=start\nclass Solution:\ndef compareVersion(self, version1: str, version2: str) -&gt; int:\nv1 = [int(i) for i in version1.split('.')]\nv2 = [int(i) for i in version2.split('.')]\nl = max(len(v1), len(v2))\nv1 += [0] * (l-len(v1))\nv2 += [0] * (l-len(v2))\nfor a, b in zip(v1, v2):\nif a &gt; b:\nreturn 1\nelif a &lt; b:\nreturn -1\nreturn 0\n# @lc code=end\n</code></pre>","tags":["Two Pointers","String"]},{"location":"19.remove-nth-node-from-end-of-list/","title":"19. Remove Nth Node From End of List","text":"<p>Problem Page: https://leetcode.com/problems/remove-nth-node-from-end-of-list/</p> <pre><code>#\n# @lc app=leetcode id=19 lang=python3\n#\n# [19] Remove Nth Node From End of List\n#\n# https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/\n#\n# algorithms\n# Medium (41.18%)\n# Likes:    17192\n# Dislikes: 706\n# Total Accepted:    2.2M\n# Total Submissions: 5.2M\n# Testcase Example:  '[1,2,3,4,5]\\n2'\n#\n# Given the head of a linked list, remove the n^th node from the end of the\n# list and return its head.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [1,2,3,4,5], n = 2\n# Output: [1,2,3,5]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [1], n = 1\n# Output: []\n#\n#\n# Example 3:\n#\n#\n# Input: head = [1,2], n = 1\n# Output: [1]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is sz.\n# 1 &lt;= sz &lt;= 30\n# 0 &lt;= Node.val &lt;= 100\n# 1 &lt;= n &lt;= sz\n#\n#\n#\n# Follow up: Could you do this in one pass?\n#\n#\n# @lc code=start\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\nd = ListNode(-1, next=head)\nf = s = d\n# c = 0\n# while f:\n#     if c &lt;= n:\n#         c += 1\n#     else:\n#         s = s.next\n#     f = f.next\nfor _ in range(n+1):\nf = f.next\nwhile f:\ns = s.next\nf = f.next\ns.next = s.next.next\nreturn d.next\n# @lc code=end\n</code></pre>","tags":["Linked List","Two Pointers"]},{"location":"2.add-two-numbers/","title":"2. Add Two Numbers","text":"<p>Problem Page: https://leetcode.com/problems/add-two-numbers/</p> <pre><code>#\n# @lc app=leetcode id=2 lang=python3\n#\n# [2] Add Two Numbers\n#\n# https://leetcode.com/problems/add-two-numbers/description/\n#\n# algorithms\n# Medium (40.41%)\n# Likes:    25480\n# Dislikes: 4941\n# Total Accepted:    3.6M\n# Total Submissions: 8.8M\n# Testcase Example:  '[2,4,3]\\n[5,6,4]'\n#\n# You are given two non-empty linked lists representing two non-negative\n# integers. The digits are stored in reverse order, and each of their nodes\n# contains a single digit. Add the two numbers and return the sum\u00a0as a linked\n# list.\n#\n# You may assume the two numbers do not contain any leading zero, except the\n# number 0 itself.\n#\n#\n# Example 1:\n#\n#\n# Input: l1 = [2,4,3], l2 = [5,6,4]\n# Output: [7,0,8]\n# Explanation: 342 + 465 = 807.\n#\n#\n# Example 2:\n#\n#\n# Input: l1 = [0], l2 = [0]\n# Output: [0]\n#\n#\n# Example 3:\n#\n#\n# Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# Output: [8,9,9,9,0,0,0,1]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in each linked list is in the range [1, 100].\n# 0 &lt;= Node.val &lt;= 9\n# It is guaranteed that the list represents a number that does not have leading\n# zeros.\n#\n#\n#\n# @lc code=start\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\nc = 0\nhead = node = None\nwhile l1 or l2 or c:\nx = c\nif l1:\nx += l1.val\nl1 = l1.next\nif l2:\nx += l2.val\nl2 = l2.next\nif not head:\nhead = node = ListNode(x % 10)\nelse:\nnode.next = ListNode(x % 10)\nnode = node.next\nc = x // 10\nreturn head\n# @lc code=end\n</code></pre>","tags":["Linked List","Math","Recursion"]},{"location":"202.happy-number/","title":"202. Happy Number","text":"<p>Problem Page: https://leetcode.com/problems/happy-number/</p> <pre><code>#\n# @lc app=leetcode id=202 lang=python3\n#\n# [202] Happy Number\n#\n# https://leetcode.com/problems/happy-number/description/\n#\n# algorithms\n# Easy (54.87%)\n# Likes:    9544\n# Dislikes: 1258\n# Total Accepted:    1.3M\n# Total Submissions: 2.3M\n# Testcase Example:  '19'\n#\n# Write an algorithm to determine if a number n is happy.\n#\n# A happy number is a number defined by the following process:\n#\n#\n# Starting with any positive integer, replace the number by the sum of the\n# squares of its digits.\n# Repeat the process until the number equals 1 (where it will stay), or it\n# loops endlessly in a cycle which does not include 1.\n# Those numbers for which this process ends in 1 are happy.\n#\n#\n# Return true if n is a happy number, and false if not.\n#\n#\n# Example 1:\n#\n#\n# Input: n = 19\n# Output: true\n# Explanation:\n# 1^2 + 9^2 = 82\n# 8^2 + 2^2 = 68\n# 6^2 + 8^2 = 100\n# 1^2 + 0^2 + 0^2 = 1\n#\n#\n# Example 2:\n#\n#\n# Input: n = 2\n# Output: false\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= n &lt;= 2^31 - 1\n#\n#\n#\n# @lc code=start\nclass Solution:\ndef isHappy(self, n: int) -&gt; bool:\ns = set()\nwhile n not in s:\ns.add(n)\nif n == 1:\nreturn True\nn = self.fn(n)\nreturn False\n@staticmethod\ndef fn(x: int):\nt = 0\nwhile x &gt; 0:\nm = x % 10\nt += m*m\nx //= 10\nreturn t\n# @lc code=end\n</code></pre>","tags":["Hash Table","Math","Two Pointers"]},{"location":"203.remove-linked-list-elements/","title":"203. Remove Linked List Elements","text":"<p>Problem Page: https://leetcode.com/problems/remove-linked-list-elements/</p> <pre><code>#\n# @lc app=leetcode id=203 lang=python3\n#\n# [203] Remove Linked List Elements\n#\n# https://leetcode.com/problems/remove-linked-list-elements/description/\n#\n# algorithms\n# Easy (46.10%)\n# Likes:    7779\n# Dislikes: 217\n# Total Accepted:    1M\n# Total Submissions: 2.1M\n# Testcase Example:  '[1,2,6,3,4,5,6]\\n6'\n#\n# Given the head of a linked list and an integer val, remove all the nodes of\n# the linked list that has Node.val == val, and return the new head.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [1,2,6,3,4,5,6], val = 6\n# Output: [1,2,3,4,5]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [], val = 1\n# Output: []\n#\n#\n# Example 3:\n#\n#\n# Input: head = [7,7,7,7], val = 7\n# Output: []\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is in the range [0, 10^4].\n# 1 &lt;= Node.val &lt;= 50\n# 0 &lt;= val &lt;= 50\n#\n#\n#\n# @lc code=start\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\nd = ListNode(next=head)\nc = d\nwhile c.next:\nif c.next.val == val:\nc.next = c.next.next\nelse:\nc = c.next\nreturn d.next\n# @lc code=end\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"206.reverse-linked-list/","title":"206. Reverse Linked List","text":"<p>Problem Page: https://leetcode.com/problems/reverse-linked-list/</p> <pre><code>#\n# @lc app=leetcode id=206 lang=python3\n#\n# [206] Reverse Linked List\n#\n# https://leetcode.com/problems/reverse-linked-list/description/\n#\n# algorithms\n# Easy (73.66%)\n# Likes:    19643\n# Dislikes: 357\n# Total Accepted:    3.4M\n# Total Submissions: 4.6M\n# Testcase Example:  '[1,2,3,4,5]'\n#\n# Given the head of a singly linked list, reverse the list, and return the\n# reversed list.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [1,2,3,4,5]\n# Output: [5,4,3,2,1]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [1,2]\n# Output: [2,1]\n#\n#\n# Example 3:\n#\n#\n# Input: head = []\n# Output: []\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is the range [0, 5000].\n# -5000 &lt;= Node.val &lt;= 5000\n#\n#\n#\n# Follow up: A linked list can be reversed either iteratively or recursively.\n# Could you implement both?\n#\n#\n# @lc code=start\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\npre = None\ncur = head\nwhile cur:\ntmp = cur\ncur = cur.next\ntmp.next = pre\npre = tmp\nreturn pre\n# @lc code=end\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"209.minimum-size-subarray-sum/","title":"209. Minimum Size Subarray Sum","text":"<p>Problem Page: https://leetcode.com/problems/minimum-size-subarray-sum/</p> <pre><code>#\n# @lc app=leetcode id=209 lang=python3\n#\n# [209] Minimum Size Subarray Sum\n#\n# https://leetcode.com/problems/minimum-size-subarray-sum/description/\n#\n# algorithms\n# Medium (45.03%)\n# Likes:    11653\n# Dislikes: 338\n# Total Accepted:    847.8K\n# Total Submissions: 1.8M\n# Testcase Example:  '7\\n[2,3,1,2,4,3]'\n#\n# Given an array of positive integers nums and a positive integer target,\n# return the minimal length of a subarray whose sum is greater than or equal to\n# target. If there is no such subarray, return 0 instead.\n#\n#\n# Example 1:\n#\n#\n# Input: target = 7, nums = [2,3,1,2,4,3]\n# Output: 2\n# Explanation: The subarray [4,3] has the minimal length under the problem\n# constraint.\n#\n#\n# Example 2:\n#\n#\n# Input: target = 4, nums = [1,4,4]\n# Output: 1\n#\n#\n# Example 3:\n#\n#\n# Input: target = 11, nums = [1,1,1,1,1,1,1,1]\n# Output: 0\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= target &lt;= 10^9\n# 1 &lt;= nums.length &lt;= 10^5\n# 1 &lt;= nums[i] &lt;= 10^4\n#\n#\n#\n# Follow up: If you have figured out the O(n) solution, try coding another\n# solution of which the time complexity is O(n log(n)).\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:\n# l = len(nums)\n# res = float('inf')\n# for i in range(l):\n#     s = 0\n#     for j in range(i, l):\n#         s += nums[j]\n#         if s &gt;= target:\n#             res = min(j-i+1, res)\n#             break\n# return res if res != float('inf') else 0\n# i = j = 0\n# res = float('inf')\n# s = nums[0]\n# while i &lt;= j &lt; len(nums):\n#     if s &gt;= target:\n#         res = min(j-i+1, res)\n#         s -= nums[i]\n#         i += 1\n#     else:\n#         j += 1\n#         s += nums[j] if j &lt; len(nums) else 0\n# return res if res != float('inf') else 0\ni = j = 0\nres = float('inf')\ns = 0\nwhile j &lt; len(nums):\ns += nums[j]\nwhile s &gt;= target:\nres = min(j-i+1, res)\ns -= nums[i]\ni += 1\nj += 1\nreturn res if res != float('inf') else 0\n# @lc code=end\n</code></pre>","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"242.valid-anagram/","title":"242. Valid Anagram","text":"<p>Problem Page: https://leetcode.com/problems/valid-anagram/</p> <pre><code>#\n# @lc app=leetcode id=242 lang=python3\n#\n# [242] Valid Anagram\n#\n# https://leetcode.com/problems/valid-anagram/description/\n#\n# algorithms\n# Easy (63.08%)\n# Likes:    10622\n# Dislikes: 331\n# Total Accepted:    2.6M\n# Total Submissions: 4.2M\n# Testcase Example:  '\"anagram\"\\n\"nagaram\"'\n#\n# Given two strings s and t, return true if t is an anagram of s, and false\n# otherwise.\n#\n# An Anagram is a word or phrase formed by rearranging the letters of a\n# different word or phrase, typically using all the original letters exactly\n# once.\n#\n#\n# Example 1:\n# Input: s = \"anagram\", t = \"nagaram\"\n# Output: true\n# Example 2:\n# Input: s = \"rat\", t = \"car\"\n# Output: false\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= s.length, t.length &lt;= 5 * 10^4\n# s and t consist of lowercase English letters.\n#\n#\n#\n# Follow up: What if the inputs contain Unicode characters? How would you adapt\n# your solution to such a case?\n#\n#\n# @lc code=start\nclass Solution:\ndef isAnagram(self, s: str, t: str) -&gt; bool:\n# sort lists:\n# return sorted(s) == sorted(t)\nm = {}\nfor i in s:\nm.setdefault(i, 0)\nm[i] += 1\nfor i in t:\nm.setdefault(i, 0)\nm[i] -= 1\nfor i in m.values():\nif i != 0:\nreturn False\nreturn True\n# @lc code=end\n</code></pre>","tags":["Hash Table","String","Sorting"]},{"location":"27.remove-element/","title":"27. Remove Element","text":"<p>Problem Page: https://leetcode.com/problems/remove-element/</p> <pre><code>#\n# @lc app=leetcode id=27 lang=python3\n#\n# [27] Remove Element\n#\n# https://leetcode.com/problems/remove-element/description/\n#\n# algorithms\n# Easy (53.10%)\n# Likes:    1201\n# Dislikes: 1594\n# Total Accepted:    2.1M\n# Total Submissions: 3.9M\n# Testcase Example:  '[3,2,2,3]\\n3'\n#\n# Given an integer array nums and an integer val, remove all occurrences of val\n# in nums in-place. The order of the elements may be changed. Then return the\n# number of elements in nums which are not equal to val.\n#\n# Consider the number of elements in nums which are not equal to val be k, to\n# get accepted, you need to do the following things:\n#\n#\n# Change the array nums such that the first k elements of nums contain the\n# elements which are not equal to val. The remaining elements of nums are not\n# important as well as the size of nums.\n# Return k.\n#\n#\n# Custom Judge:\n#\n# The judge will test your solution with the following code:\n#\n#\n# int[] nums = [...]; // Input array\n# int val = ...; // Value to remove\n# int[] expectedNums = [...]; // The expected answer with correct length.\n# \u2060                           // It is sorted with no values equaling val.\n#\n# int k = removeElement(nums, val); // Calls your implementation\n#\n# assert k == expectedNums.length;\n# sort(nums, 0, k); // Sort the first k elements of nums\n# for (int i = 0; i &lt; actualLength; i++) {\n# \u2060   assert nums[i] == expectedNums[i];\n# }\n#\n#\n# If all assertions pass, then your solution will be accepted.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [3,2,2,3], val = 3\n# Output: 2, nums = [2,2,_,_]\n# Explanation: Your function should return k = 2, with the first two elements\n# of nums being 2.\n# It does not matter what you leave beyond the returned k (hence they are\n# underscores).\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [0,1,2,2,3,0,4,2], val = 2\n# Output: 5, nums = [0,1,4,0,3,_,_,_]\n# Explanation: Your function should return k = 5, with the first five elements\n# of nums containing 0, 0, 1, 3, and 4.\n# Note that the five elements can be returned in any order.\n# It does not matter what you leave beyond the returned k (hence they are\n# underscores).\n#\n#\n#\n# Constraints:\n#\n#\n# 0 &lt;= nums.length &lt;= 100\n# 0 &lt;= nums[i] &lt;= 50\n# 0 &lt;= val &lt;= 100\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef removeElement(self, nums: List[int], val: int) -&gt; int:\ns = 0\nl = len(nums)\nfor f in range(l):\nif nums[f] != val:\nnums[s] = nums[f]\ns += 1\nreturn s\n# @lc code=end\n</code></pre>","tags":["Array","Two Pointers"]},{"location":"349.intersection-of-two-arrays/","title":"349. Intersection of Two Arrays","text":"<p>Problem Page: https://leetcode.com/problems/intersection-of-two-arrays/</p> <pre><code>#\n# @lc app=leetcode id=349 lang=python3\n#\n# [349] Intersection of Two Arrays\n#\n# https://leetcode.com/problems/intersection-of-two-arrays/description/\n#\n# algorithms\n# Easy (70.98%)\n# Likes:    5261\n# Dislikes: 2189\n# Total Accepted:    923.3K\n# Total Submissions: 1.3M\n# Testcase Example:  '[1,2,2,1]\\n[2,2]'\n#\n# Given two integer arrays nums1 and nums2, return an array of their\n# intersection. Each element in the result must be unique and you may return\n# the result in any order.\n#\n#\n# Example 1:\n#\n#\n# Input: nums1 = [1,2,2,1], nums2 = [2,2]\n# Output: [2]\n#\n#\n# Example 2:\n#\n#\n# Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n# Output: [9,4]\n# Explanation: [4,9] is also accepted.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= nums1.length, nums2.length &lt;= 1000\n# 0 &lt;= nums1[i], nums2[i] &lt;= 1000\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n# # Set solution:\n# s1 = set(nums1)\n# s2 = set(nums2)\n# return list(s1 &amp; s2)\n# Array solution:\nsize = 1001\na1 = [0] * size\na2 = [0] * size\nfor i in nums1:\na1[i] = 1\nfor i in nums2:\na2[i] = 1\nres = []\nfor i in range(size):\nif a1[i]*a2[i] &gt; 0:\nres.append(i)\nreturn res\n# @lc code=end\n</code></pre>","tags":["Array","Hash Table","Two Pointers","Binary Search","Sorting"]},{"location":"454.4-sum-ii/","title":"454. 4Sum II","text":"<p>Problem Page: https://leetcode.com/problems/4sum-ii/</p> <pre><code>#\n# @lc app=leetcode id=454 lang=python3\n#\n# [454] 4Sum II\n#\n# https://leetcode.com/problems/4sum-ii/description/\n#\n# algorithms\n# Medium (57.19%)\n# Likes:    4755\n# Dislikes: 135\n# Total Accepted:    306.2K\n# Total Submissions: 536K\n# Testcase Example:  '[1,2]\\n[-2,-1]\\n[-1,2]\\n[0,2]'\n#\n# Given four integer arrays nums1, nums2, nums3, and nums4 all of length n,\n# return the number of tuples (i, j, k, l) such that:\n#\n#\n# 0 &lt;= i, j, k, l &lt; n\n# nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n#\n#\n#\n# Example 1:\n#\n#\n# Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n# Output: 2\n# Explanation:\n# The two tuples are:\n# 1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) +\n# (-1) + 2 = 0\n# 2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) +\n# (-1) + 0 = 0\n#\n#\n# Example 2:\n#\n#\n# Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n# Output: 1\n#\n#\n#\n# Constraints:\n#\n#\n# n == nums1.length\n# n == nums2.length\n# n == nums3.length\n# n == nums4.length\n# 1 &lt;= n &lt;= 200\n# -2^28 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^28\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:\n# # Brute solution: (time exceeded)\n#\n# c = 0\n# for ki, vi in enumerate(nums1):\n#     for kj, vj in enumerate(nums2):\n#         for km, vm in enumerate(nums3):\n#             for kn, vn in enumerate(nums4):\n#                 if vi + vj + vm + vn == 0:\n#                     c += 1\n# return c\nfrom collections import defaultdict\nc = 0\nma = defaultdict(int)\n# mb = defaultdict(int)\nfor i in nums1:\nfor j in nums2:\nma[i + j] += 1\nfor i in nums3:\nfor j in nums4:\nif -(i+j) in ma:\nc += ma[-(i+j)]\nreturn c\n# @lc code=end\n</code></pre>","tags":["Array","Hash Table"]},{"location":"54.spiral-matrix/","title":"54. Spiral Matrix","text":"<p>Problem Page: https://leetcode.com/problems/spiral-matrix/</p> <pre><code>#\n# @lc app=leetcode id=54 lang=python3\n#\n# [54] Spiral Matrix\n#\n# https://leetcode.com/problems/spiral-matrix/description/\n#\n# algorithms\n# Medium (45.09%)\n# Likes:    13485\n# Dislikes: 1170\n# Total Accepted:    1.2M\n# Total Submissions: 2.5M\n# Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'\n#\n# Given an m x n matrix, return all elements of the matrix in spiral order.\n#\n#\n# Example 1:\n#\n#\n# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n# Output: [1,2,3,6,9,8,7,4,5]\n#\n#\n# Example 2:\n#\n#\n# Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n# Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n#\n#\n#\n# Constraints:\n#\n#\n# m == matrix.length\n# n == matrix[i].length\n# 1 &lt;= m, n &lt;= 10\n# -100 &lt;= matrix[i][j] &lt;= 100\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:\nm = len(matrix[0])\nn = len(matrix)\no = 0\nres = []\nwhile m &gt; 0 and n &gt; 0:\nfor i in self.walk(matrix, m, n, o):\nres.append(i)\nm -= 2\nn -= 2\no += 1\nreturn res\n@staticmethod\ndef walk(a, m, n, o):\nx = y = 0\nd = 0\nloops = m*2+(n-2)*2 if m &gt; 2 and n &gt; 2 else m*n\nfor _ in range(loops):\nyield a[x+o][y+o]\nif d == 0:\nif y &lt; m - 1:\ny += 1\nelse:\nd += 1\nx += 1\nelif d == 1:\nif x &lt; n - 1:\nx += 1\nelse:\nd += 1\ny -= 1\nelif d == 2:\nif y &gt; 0:\ny -= 1\nelse:\nd += 1\nx -= 1\nelif d == 3:\nx -= 1\n# @lc code=end\n</code></pre>","tags":["Array","Matrix","Simulation"]},{"location":"59.spiral-matrix-ii/","title":"59. Spiral Matrix II","text":"<p>Problem Page: https://leetcode.com/problems/spiral-matrix-ii/</p> <pre><code>#\n# @lc app=leetcode id=59 lang=python3\n#\n# [59] Spiral Matrix II\n#\n# https://leetcode.com/problems/spiral-matrix-ii/description/\n#\n# algorithms\n# Medium (67.47%)\n# Likes:    6010\n# Dislikes: 239\n# Total Accepted:    519.1K\n# Total Submissions: 740.3K\n# Testcase Example:  '3'\n#\n# Given a positive integer n, generate an n x n matrix filled with elements\n# from 1 to n^2 in spiral order.\n#\n#\n# Example 1:\n#\n#\n# Input: n = 3\n# Output: [[1,2,3],[8,9,4],[7,6,5]]\n#\n#\n# Example 2:\n#\n#\n# Input: n = 1\n# Output: [[1]]\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= n &lt;= 20\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef generateMatrix(self, n: int) -&gt; List[List[int]]:\nres = [\n[0 for _ in range(n)]\nfor _ in range(n)\n]\ni = 1\noffset = 0\nwhile n &gt; 0:\ni = draw(res, n, i, offset)\noffset += 1\nn -= 2\nreturn res\ndef draw(a, n, i, offset):\nif n == 1:\na[offset][offset] = i\nreturn i+1\nx = y = 0\nd = 0\nfor _ in range(4*(n-1)):\n# print(x, y, i, d)\na[offset+x][offset+y] = i\nif d % 4 == 0:\nif y &lt; n - 1:\ny += 1\nelse:\nd += 1\nx += 1\nelif d % 4 == 1:\nif x &lt; n - 1:\nx += 1\nelse:\nd += 1\ny -= 1\nelif d % 4 == 2:\nif y &gt; 0:\ny -= 1\nelse:\nd += 1\nx -= 1\nelif d % 4 == 3:\nif x &gt; 1:\nx -= 1\ni += 1\nreturn i\n# @lc code=end\n</code></pre>","tags":["Array","Matrix","Simulation"]},{"location":"704.binary-search/","title":"704. Binary Search","text":"<p>Problem Page: https://leetcode.com/problems/binary-search/</p> <pre><code>#\n# @lc app=leetcode id=704 lang=python3\n#\n# [704] Binary Search\n#\n# https://leetcode.com/problems/binary-search/description/\n#\n# algorithms\n# Easy (56.17%)\n# Likes:    10770\n# Dislikes: 215\n# Total Accepted:    2M\n# Total Submissions: 3.5M\n# Testcase Example:  '[-1,0,3,5,9,12]\\n9'\n#\n# Given an array of integers nums which is sorted in ascending order, and an\n# integer target, write a function to search target in nums. If target exists,\n# then return its index. Otherwise, return -1.\n#\n# You must write an algorithm with O(log n) runtime complexity.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [-1,0,3,5,9,12], target = 9\n# Output: 4\n# Explanation: 9 exists in nums and its index is 4\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [-1,0,3,5,9,12], target = 2\n# Output: -1\n# Explanation: 2 does not exist in nums so return -1\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= nums.length &lt;= 10^4\n# -10^4 &lt; nums[i], target &lt; 10^4\n# All the integers in nums are unique.\n# nums is sorted in ascending order.\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef search(self, nums: List[int], target: int) -&gt; int:\ni = 0\nj = len(nums) - 1\nwhile i &lt;= j:\nm = (i+j)//2\nif nums[m] &gt; target:\nj = m - 1\nelif nums[m] &lt; target:\ni = m + 1\nelse:\nreturn m\nreturn -1\n# @lc code=end\n</code></pre>","tags":["Array","Binary Search"]},{"location":"707.design-linked-list/","title":"707. Design Linked List","text":"<p>Problem Page: https://leetcode.com/problems/design-linked-list/</p> <pre><code>#\n# @lc app=leetcode id=707 lang=python3\n#\n# [707] Design Linked List\n#\n# https://leetcode.com/problems/design-linked-list/description/\n#\n# algorithms\n# Medium (27.67%)\n# Likes:    2416\n# Dislikes: 1520\n# Total Accepted:    283.7K\n# Total Submissions: 1M\n# Testcase Example:  '[\"MyLinkedList\",\"addAtHead\",\"addAtTail\",\"addAtIndex\",\"get\",\"deleteAtIndex\",\"get\"]\\n' +\n# '[[],[1],[3],[1,2],[1],[1],[1]]'\n#\n# Design your implementation of the linked list. You can choose to use a singly\n# or doubly linked list.\n# A node in a singly linked list should have two attributes: val and next. val\n# is the value of the current node, and next is a pointer/reference to the next\n# node.\n# If you want to use the doubly linked list, you will need one more attribute\n# prev to indicate the previous node in the linked list. Assume all nodes in\n# the linked list are 0-indexed.\n#\n# Implement the MyLinkedList class:\n#\n#\n# MyLinkedList() Initializes the MyLinkedList object.\n# int get(int index) Get the value of the index^th node in the linked list. If\n# the index is invalid, return -1.\n# void addAtHead(int val) Add a node of value val before the first element of\n# the linked list. After the insertion, the new node will be the first node of\n# the linked list.\n# void addAtTail(int val) Append a node of value val as the last element of the\n# linked list.\n# void addAtIndex(int index, int val) Add a node of value val before the\n# index^th node in the linked list. If index equals the length of the linked\n# list, the node will be appended to the end of the linked list. If index is\n# greater than the length, the node will not be inserted.\n# void deleteAtIndex(int index) Delete the index^th node in the linked list, if\n# the index is valid.\n#\n#\n#\n# Example 1:\n#\n#\n# Input\n# [\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\",\n# \"deleteAtIndex\", \"get\"]\n# [[], [1], [3], [1, 2], [1], [1], [1]]\n# Output\n# [null, null, null, null, 2, null, 3]\n#\n# Explanation\n# MyLinkedList myLinkedList = new MyLinkedList();\n# myLinkedList.addAtHead(1);\n# myLinkedList.addAtTail(3);\n# myLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3\n# myLinkedList.get(1);              // return 2\n# myLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3\n# myLinkedList.get(1);              // return 3\n#\n#\n#\n# Constraints:\n#\n#\n# 0 &lt;= index, val &lt;= 1000\n# Please do not use the built-in LinkedList library.\n# At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and\n# deleteAtIndex.\n#\n#\n#\n# @lc code=start\nclass node:\ndef __init__(self, val=0, next=None):\nself.val: int = val\nself.next: node = next\nclass MyLinkedList:\ndef __init__(self):\nself.node = node(-1)\nself.size = 0\ndef get(self, index: int) -&gt; int:\nif index &lt; 0 or index &gt;= self.size:\nreturn -1\nh = self.node.next\nfor _ in range(index):\nh = h.next\nreturn h.val\ndef addAtHead(self, val: int) -&gt; None:\n# self.size += 1\n# self.node.next = node(val, next=self.node.next)\nself.addAtIndex(0, val)\ndef addAtTail(self, val: int) -&gt; None:\n# h = self.node\n# for _ in range(self.size):\n#     h = h.next\n# h.next = node(val)\n# self.size += 1\nself.addAtIndex(self.size, val)\ndef addAtIndex(self, index: int, val: int) -&gt; None:\nif index &lt; 0 or index &gt; self.size:\nreturn\nh = self.node\nfor _ in range(index):\nh = h.next\nh.next = node(val, next=h.next)\nself.size += 1\ndef deleteAtIndex(self, index: int) -&gt; None:\nif index &lt; 0 or index &gt;= self.size:\nreturn\nh = self.node\nfor _ in range(index):\nh = h.next\nh.next = h.next.next\nself.size -= 1\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)\n# @lc code=end\n</code></pre>","tags":["Linked List","Design"]},{"location":"9.palindrome-number/","title":"9. Palindrome Number","text":"<p>Problem Page: https://leetcode.com/problems/palindrome-number/</p> <pre><code>#\n# @lc app=leetcode id=9 lang=python3\n#\n# [9] Palindrome Number\n#\n# https://leetcode.com/problems/palindrome-number/description/\n#\n# algorithms\n# Easy (53.59%)\n# Likes:    9317\n# Dislikes: 2482\n# Total Accepted:    3.1M\n# Total Submissions: 5.8M\n# Testcase Example:  '121'\n#\n# Given an integer x, return true if x is a palindrome, and false otherwise.\n#\n#\n# Example 1:\n#\n#\n# Input: x = 121\n# Output: true\n# Explanation: 121 reads as 121 from left to right and from right to left.\n#\n#\n# Example 2:\n#\n#\n# Input: x = -121\n# Output: false\n# Explanation: From left to right, it reads -121. From right to left, it\n# becomes 121-. Therefore it is not a palindrome.\n#\n#\n# Example 3:\n#\n#\n# Input: x = 10\n# Output: false\n# Explanation: Reads 01 from right to left. Therefore it is not a\n# palindrome.\n#\n#\n#\n# Constraints:\n#\n#\n# -2^31\u00a0&lt;= x &lt;= 2^31\u00a0- 1\n#\n#\n#\n# Follow up: Could you solve it without converting the integer to a string?\n#\n# @lc code=start\nclass Solution:\ndef isPalindrome(self, x: int) -&gt; bool:\n# the python way\n# return str(x) == str(x)[::-1]\n# Convert to string\n#\n# s = str(x)\n# i = 0\n# j = len(s) - 1\n# while i &lt;= j:\n#     if s[i] != s[j]:\n#         return False\n#     i += 1\n#     j -= 1\n# return True\n# Math operation\nif x &lt; 0:\nreturn False\ni = x\ny = 0\nwhile i &gt; 0:\ny = y*10+i % 10\ni //= 10\nreturn x == y\n# @lc code=end\n</code></pre>","tags":["Math"]},{"location":"977.squares-of-a-sorted-array/","title":"977. Squares of a Sorted Array","text":"<p>Problem Page: https://leetcode.com/problems/squares-of-a-sorted-array/</p> <pre><code>#\n# @lc app=leetcode id=977 lang=python3\n#\n# [977] Squares of a Sorted Array\n#\n# https://leetcode.com/problems/squares-of-a-sorted-array/description/\n#\n# algorithms\n# Easy (71.89%)\n# Likes:    8325\n# Dislikes: 204\n# Total Accepted:    1.5M\n# Total Submissions: 2.1M\n# Testcase Example:  '[-4,-1,0,3,10]'\n#\n# Given an integer array nums sorted in non-decreasing order, return an array\n# of the squares of each number sorted in non-decreasing order.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [-4,-1,0,3,10]\n# Output: [0,1,9,16,100]\n# Explanation: After squaring, the array becomes [16,1,0,9,100].\n# After sorting, it becomes [0,1,9,16,100].\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [-7,-3,2,3,11]\n# Output: [4,9,9,49,121]\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= nums.length &lt;= 10^4\n# -10^4 &lt;= nums[i] &lt;= 10^4\n# nums is sorted in non-decreasing order.\n#\n#\n#\n# Follow up: Squaring each element and sorting the new array is very trivial,\n# could you find an O(n) solution using a different approach?\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef sortedSquares(self, nums: List[int]) -&gt; List[int]:\n# solution 1:\n# return sorted((n*n for n in nums))\n# solution 2:\ni = 0\nk = j = len(nums) - 1\nres = [None for _ in nums]\nwhile i &lt;= j:\nx = nums[i]\ny = nums[j]\nif abs(x) &gt; abs(y):\nres[k] = x*x\ni += 1\nelse:\nres[k] = y*y\nj -= 1\nk -= 1\nreturn res\n# @lc code=end\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"topic-tags/","title":"Topic Tags","text":""},{"location":"topic-tags/#array","title":"Array","text":"<ul> <li>1. Two Sum</li> <li>209. Minimum Size Subarray Sum</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>454. 4Sum II</li> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> <li>704. Binary Search</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#binary-search","title":"Binary Search","text":"<ul> <li>209. Minimum Size Subarray Sum</li> <li>349. Intersection of Two Arrays</li> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#design","title":"Design","text":"<ul> <li>707. Design Linked List</li> </ul>"},{"location":"topic-tags/#hash-table","title":"Hash Table","text":"<ul> <li>1. Two Sum</li> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>202. Happy Number</li> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>454. 4Sum II</li> </ul>"},{"location":"topic-tags/#linked-list","title":"Linked List","text":"<ul> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>19. Remove Nth Node From End of List</li> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> <li>707. Design Linked List</li> </ul>"},{"location":"topic-tags/#math","title":"Math","text":"<ul> <li>2. Add Two Numbers</li> <li>202. Happy Number</li> <li>9. Palindrome Number</li> </ul>"},{"location":"topic-tags/#matrix","title":"Matrix","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> </ul>"},{"location":"topic-tags/#prefix-sum","title":"Prefix Sum","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#recursion","title":"Recursion","text":"<ul> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> </ul>"},{"location":"topic-tags/#simulation","title":"Simulation","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> </ul>"},{"location":"topic-tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#sorting","title":"Sorting","text":"<ul> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#string","title":"String","text":"<ul> <li>14. Longest Common Prefix</li> <li>165. Compare Version Numbers</li> <li>242. Valid Anagram</li> </ul>"},{"location":"topic-tags/#trie","title":"Trie","text":"<ul> <li>14. Longest Common Prefix</li> </ul>"},{"location":"topic-tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>165. Compare Version Numbers</li> <li>19. Remove Nth Node From End of List</li> <li>202. Happy Number</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/","title":"Topic Tags","text":""},{"location":"topic-tags/#array","title":"Array","text":"<ul> <li>1. Two Sum</li> <li>209. Minimum Size Subarray Sum</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>454. 4Sum II</li> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> <li>704. Binary Search</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#binary-search","title":"Binary Search","text":"<ul> <li>209. Minimum Size Subarray Sum</li> <li>349. Intersection of Two Arrays</li> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#design","title":"Design","text":"<ul> <li>707. Design Linked List</li> </ul>"},{"location":"topic-tags/#hash-table","title":"Hash Table","text":"<ul> <li>1. Two Sum</li> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>202. Happy Number</li> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>454. 4Sum II</li> </ul>"},{"location":"topic-tags/#linked-list","title":"Linked List","text":"<ul> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>19. Remove Nth Node From End of List</li> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> <li>707. Design Linked List</li> </ul>"},{"location":"topic-tags/#math","title":"Math","text":"<ul> <li>2. Add Two Numbers</li> <li>202. Happy Number</li> <li>9. Palindrome Number</li> </ul>"},{"location":"topic-tags/#matrix","title":"Matrix","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> </ul>"},{"location":"topic-tags/#prefix-sum","title":"Prefix Sum","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#recursion","title":"Recursion","text":"<ul> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> </ul>"},{"location":"topic-tags/#simulation","title":"Simulation","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> </ul>"},{"location":"topic-tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#sorting","title":"Sorting","text":"<ul> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#string","title":"String","text":"<ul> <li>14. Longest Common Prefix</li> <li>165. Compare Version Numbers</li> <li>242. Valid Anagram</li> </ul>"},{"location":"topic-tags/#trie","title":"Trie","text":"<ul> <li>14. Longest Common Prefix</li> </ul>"},{"location":"topic-tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>165. Compare Version Numbers</li> <li>19. Remove Nth Node From End of List</li> <li>202. Happy Number</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>977. Squares of a Sorted Array</li> </ul>"}]}