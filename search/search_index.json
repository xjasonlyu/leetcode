{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dashboard","text":""},{"location":"#dashboard","title":"Dashboard","text":"<p>GitHub Pages: https://xjasonlyu.github.io/leetcode</p> <p>Source Code: https://github.com/xjasonlyu/leetcode</p> <p></p> <p>Some Basic Algorithms:</p> <ul> <li>Binary Search Algorithm</li> <li>Merge Sort Algorithm</li> <li>Quicksort Algorithm</li> <li>Kruskal\u2019s Algorithm</li> <li>Breadth First Search (BFS) Algorithm</li> <li>Depth First Search (DFS) Algorithm</li> </ul> <p>This site is powered by Material for MkDocs and GitHub Pages.</p>"},{"location":"1.two-sum/","title":"1. Two Sum","text":"<p>Problem Page: https://leetcode.com/problems/two-sum/</p> <pre><code>#\n# @lc app=leetcode id=1 lang=python3\n#\n# [1] Two Sum\n#\n# https://leetcode.com/problems/two-sum/description/\n#\n# algorithms\n# Easy (49.76%)\n# Likes:    45395\n# Dislikes: 1480\n# Total Accepted:    9.4M\n# Total Submissions: 19M\n# Testcase Example:  '[2,7,11,15]\\n9'\n#\n# Given an array of integers nums\u00a0and an integer target, return indices of the\n# two numbers such that they add up to target.\n#\n# You may assume that each input would have exactly one solution, and you may\n# not use the same element twice.\n#\n# You can return the answer in any order.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [2,7,11,15], target = 9\n# Output: [0,1]\n# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [3,2,4], target = 6\n# Output: [1,2]\n#\n#\n# Example 3:\n#\n#\n# Input: nums = [3,3], target = 6\n# Output: [0,1]\n#\n#\n#\n# Constraints:\n#\n#\n# 2 &lt;= nums.length &lt;= 10^4\n# -10^9 &lt;= nums[i] &lt;= 10^9\n# -10^9 &lt;= target &lt;= 10^9\n# Only one valid answer exists.\n#\n#\n#\n# Follow-up:\u00a0Can you come up with an algorithm that is less than\u00a0O(n^2)\u00a0time\n# complexity?\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n\n        # Double for loop\n        #\n        # for i, m in enumerate(nums):\n        #     if i+1==len(nums):\n        #         return\n        #     for j, n in enumerate(nums[i+1:]):\n        #         if m+n == target:\n        #             return i, i+j+1\n\n        # Hash table\n\n        seen = {}\n        for i, value in enumerate(nums):\n            remaining = target - nums[i]\n\n            if remaining in seen:\n                return [i, seen[remaining]]\n\n            seen[value] = i\n\n# @lc code=end\n</code></pre>","tags":["Array","Hash Table"]},{"location":"1009.complement-of-base-10-integer/","title":"1009. Complement of Base 10 Integer","text":"<p>Problem Page: https://leetcode.com/problems/complement-of-base-10-integer/</p> <pre><code>#\n# @lc app=leetcode id=1009 lang=python3\n#\n# [1009] Complement of Base 10 Integer\n#\n# https://leetcode.com/problems/complement-of-base-10-integer/description/\n#\n# algorithms\n# Easy (61.45%)\n# Likes:    2224\n# Dislikes: 108\n# Total Accepted:    204.3K\n# Total Submissions: 335.1K\n# Testcase Example:  '5'\n#\n# The complement of an integer is the integer you get when you flip all the 0's\n# to 1's and all the 1's to 0's in its binary representation.\n#\n#\n# For example, The integer 5 is \"101\" in binary and its complement is \"010\"\n# which is the integer 2.\n#\n#\n# Given an integer n, return its complement.\n#\n#\n# Example 1:\n#\n#\n# Input: n = 5\n# Output: 2\n# Explanation: 5 is \"101\" in binary, with complement \"010\" in binary, which is\n# 2 in base-10.\n#\n#\n# Example 2:\n#\n#\n# Input: n = 7\n# Output: 0\n# Explanation: 7 is \"111\" in binary, with complement \"000\" in binary, which is\n# 0 in base-10.\n#\n#\n# Example 3:\n#\n#\n# Input: n = 10\n# Output: 5\n# Explanation: 10 is \"1010\" in binary, with complement \"0101\" in binary, which\n# is 5 in base-10.\n#\n#\n#\n# Constraints:\n#\n#\n# 0 &lt;= n &lt; 10^9\n#\n#\n#\n# Note: This question is the same as 476:\n# https://leetcode.com/problems/number-complement/\n#\n#\n\n# @lc code=start\nclass Solution:\n    def bitwiseComplement(self, n: int) -&gt; int:\n\n        if not n:\n            return 1\n\n        r = 0\n\n        i = 0\n\n        a = (1, 0)\n\n        while n:\n\n            x = n % 2\n\n            n &gt;&gt;= 1\n\n            r += (a[x])*2**i\n\n            i += 1\n\n        return r\n\n# @lc code=end\n</code></pre>","tags":["Bit Manipulation"]},{"location":"11.container-with-most-water/","title":"11. Container With Most Water","text":"<p>Problem Page: https://leetcode.com/problems/container-with-most-water/</p> <pre><code>#\n# @lc app=leetcode id=11 lang=python3\n#\n# [11] Container With Most Water\n#\n# https://leetcode.com/problems/container-with-most-water/description/\n#\n# algorithms\n# Medium (53.99%)\n# Likes:    28090\n# Dislikes: 1635\n# Total Accepted:    2.7M\n# Total Submissions: 5M\n# Testcase Example:  '[1,8,6,2,5,4,8,3,7]'\n#\n# You are given an integer array height of length n. There are n vertical lines\n# drawn such that the two endpoints of the i^th line are (i, 0) and (i,\n# height[i]).\n# \n# Find two lines that together with the x-axis form a container, such that the\n# container contains the most water.\n# \n# Return the maximum amount of water a container can store.\n# \n# Notice that you may not slant the container.\n# \n# \n# Example 1:\n# \n# \n# Input: height = [1,8,6,2,5,4,8,3,7]\n# Output: 49\n# Explanation: The above vertical lines are represented by array\n# [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the\n# container can contain is 49.\n# \n# \n# Example 2:\n# \n# \n# Input: height = [1,1]\n# Output: 1\n# \n# \n# \n# Constraints:\n# \n# \n# n == height.length\n# 2 &lt;= n &lt;= 10^5\n# 0 &lt;= height[i] &lt;= 10^4\n# \n# \n#\n\n# @lc code=start\n\nfrom typing import List\n\nclass Solution:\n    def maxArea(self, height: List[int]) -&gt; int:\n        # O(n^2) solution:\n        # (time exceeded)\n        # l = len(height)\n        # res = 0\n        # for i in range(l-1):\n        #     for j in range(i+1, l):\n        #         res = max(res, min(height[i], height[j])*abs(j-i))\n        # return res\n\n        #two pointers:\n        l = 0\n        r = len(height) - 1\n\n        res = 0\n        while l &lt; r:\n            res = max(res, (r-l)*min(height[l], height[r]))\n            if height[l] &lt; height[r]:\n                l += 1\n            else:\n                r -= 1\n\n        return res\n\n# @lc code=end\n</code></pre>","tags":["Array","Two Pointers","Greedy"]},{"location":"14.longest-common-prefix/","title":"14. Longest Common Prefix","text":"<p>Problem Page: https://leetcode.com/problems/longest-common-prefix/</p> <pre><code>#\n# @lc app=leetcode id=14 lang=python3\n#\n# [14] Longest Common Prefix\n#\n# https://leetcode.com/problems/longest-common-prefix/description/\n#\n# algorithms\n# Easy (40.89%)\n# Likes:    13493\n# Dislikes: 3881\n# Total Accepted:    2.3M\n# Total Submissions: 5.7M\n# Testcase Example:  '[\"flower\",\"flow\",\"flight\"]'\n#\n# Write a function to find the longest common prefix string amongst an array of\n# strings.\n#\n# If there is no common prefix, return an empty string \"\".\n#\n#\n# Example 1:\n#\n#\n# Input: strs = [\"flower\",\"flow\",\"flight\"]\n# Output: \"fl\"\n#\n#\n# Example 2:\n#\n#\n# Input: strs = [\"dog\",\"racecar\",\"car\"]\n# Output: \"\"\n# Explanation: There is no common prefix among the input strings.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= strs.length &lt;= 200\n# 0 &lt;= strs[i].length &lt;= 200\n# strs[i] consists of only lowercase English letters.\n#\n#\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -&gt; str:\n\n        # the python way\n        ans = ''\n        for v in zip(*strs):\n            x = v[0]\n            for i in v:\n                if x != i:\n                    return ans\n            ans += x\n        return ans\n\n# @lc code=end\n</code></pre>","tags":["String","Trie"]},{"location":"142.linked-list-cycle-ii/","title":"142. Linked List Cycle II","text":"<p>Problem Page: https://leetcode.com/problems/linked-list-cycle-ii/</p> <pre><code>#\n# @lc app=leetcode id=142 lang=python3\n#\n# [142] Linked List Cycle II\n#\n# https://leetcode.com/problems/linked-list-cycle-ii/description/\n#\n# algorithms\n# Medium (48.87%)\n# Likes:    12740\n# Dislikes: 891\n# Total Accepted:    1.2M\n# Total Submissions: 2.3M\n# Testcase Example:  '[3,2,0,-4]\\n1'\n#\n# Given the head of a linked list, return the node where the cycle begins. If\n# there is no cycle, return null.\n#\n# There is a cycle in a linked list if there is some node in the list that can\n# be reached again by continuously following the next pointer. Internally, pos\n# is used to denote the index of the node that tail's next pointer is connected\n# to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as\n# a parameter.\n#\n# Do not modify the linked list.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [3,2,0,-4], pos = 1\n# Output: tail connects to node index 1\n# Explanation: There is a cycle in the linked list, where tail connects to the\n# second node.\n#\n#\n# Example 2:\n#\n#\n# Input: head = [1,2], pos = 0\n# Output: tail connects to node index 0\n# Explanation: There is a cycle in the linked list, where tail connects to the\n# first node.\n#\n#\n# Example 3:\n#\n#\n# Input: head = [1], pos = -1\n# Output: no cycle\n# Explanation: There is no cycle in the linked list.\n#\n#\n#\n# Constraints:\n#\n#\n# The number of the nodes in the list is in the range [0, 10^4].\n# -10^5 &lt;= Node.val &lt;= 10^5\n# pos is -1 or a valid index in the linked-list.\n#\n#\n#\n# Follow up: Can you solve it using O(1) (i.e. constant) memory?\n#\n#\n\n# @lc code=start\n# Definition for singly-linked list.\n\n# from typing import Optional\n\n\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head):\n\n        # Solution by set:\n\n        # v = set()\n\n        # while head:\n\n        #     if head in v:\n        #         return head\n\n        #     v.add(head)\n        #     head = head.next\n\n        # return\n\n        # solution by fast&amp;slow pointers\n\n        f = s = head\n\n        while True:\n\n            for _ in range(2):\n                if not f:\n                    return None\n                f = f.next\n\n            s = s.next\n\n            if f == s:\n                break\n\n        i = head\n        j = s\n\n        while i != j:\n            i = i.next\n            j = j.next\n\n        return i\n\n# @lc code=end\n</code></pre>","tags":["Hash Table","Linked List","Two Pointers"]},{"location":"15.3-sum/","title":"15. 3Sum","text":"<p>Problem Page: https://leetcode.com/problems/3sum/</p> <pre><code>#\n# @lc app=leetcode id=15 lang=python3\n#\n# [15] 3Sum\n#\n# https://leetcode.com/problems/3sum/description/\n#\n# algorithms\n# Medium (32.62%)\n# Likes:    28435\n# Dislikes: 2557\n# Total Accepted:    2.9M\n# Total Submissions: 8.8M\n# Testcase Example:  '[-1,0,1,2,-1,-4]'\n#\n# Given an integer array nums, return all the triplets [nums[i], nums[j],\n# nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] +\n# nums[k] == 0.\n#\n# Notice that the solution set must not contain duplicate triplets.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [-1,0,1,2,-1,-4]\n# Output: [[-1,-1,2],[-1,0,1]]\n# Explanation:\n# nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n# nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n# nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n# The distinct triplets are [-1,0,1] and [-1,-1,2].\n# Notice that the order of the output and the order of the triplets does not\n# matter.\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [0,1,1]\n# Output: []\n# Explanation: The only possible triplet does not sum up to 0.\n#\n#\n# Example 3:\n#\n#\n# Input: nums = [0,0,0]\n# Output: [[0,0,0]]\n# Explanation: The only possible triplet sums up to 0.\n#\n#\n#\n# Constraints:\n#\n#\n# 3 &lt;= nums.length &lt;= 3000\n# -10^5 &lt;= nums[i] &lt;= 10^5\n#\n#\n#\n\n# @lc code=start\nfrom typing import List\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n\n        # Hash table (but slow):\n\n        m = {}\n\n        res = []\n\n        for i in nums:\n            if i in m:\n                m[i] += 1\n            else:\n                m[i] = 1\n\n        k = sorted(m.keys())\n\n        for idx, i in enumerate(k):\n\n            if i &gt; 0:\n                continue\n\n            m[i] -= 1\n\n            for j in k[idx:]:\n\n                if m[j] &gt; 0:\n\n                    m[j] -= 1\n\n                    if m.get(-(i+j), -1) &gt; 0 and -(i+j) &gt;= j:\n                        res.append([i, j, -(i+j)])\n\n                    m[j] += 1\n\n            m[i] += 1\n\n        return res\n\n# @lc code=end\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"160.intersection-of-two-linked-lists/","title":"160. Intersection of Two Linked Lists","text":"<p>Problem Page: https://leetcode.com/problems/intersection-of-two-linked-lists/</p> <pre><code>#\n# @lc app=leetcode id=160 lang=python3\n#\n# [160] Intersection of Two Linked Lists\n#\n# https://leetcode.com/problems/intersection-of-two-linked-lists/description/\n#\n# algorithms\n# Easy (54.45%)\n# Likes:    14026\n# Dislikes: 1241\n# Total Accepted:    1.4M\n# Total Submissions: 2.5M\n# Testcase Example:  '8\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n2\\n3'\n#\n# Given the heads of two singly linked-lists headA and headB, return the node\n# at which the two lists intersect. If the two linked lists have no\n# intersection at all, return null.\n#\n# For example, the following two linked lists begin to intersect at node c1:\n#\n# The test cases are generated such that there are no cycles anywhere in the\n# entire linked structure.\n#\n# Note that the linked lists must retain their original structure after the\n# function returns.\n#\n# Custom Judge:\n#\n# The inputs to the judge are given as follows (your program is not given these\n# inputs):\n#\n#\n# intersectVal - The value of the node where the intersection occurs. This is 0\n# if there is no intersected node.\n# listA - The first linked list.\n# listB - The second linked list.\n# skipA - The number of nodes to skip ahead in listA (starting from the head)\n# to get to the intersected node.\n# skipB - The number of nodes to skip ahead in listB (starting from the head)\n# to get to the intersected node.\n#\n#\n# The judge will then create the linked structure based on these inputs and\n# pass the two heads, headA and headB to your program. If you correctly return\n# the intersected node, then your solution will be accepted.\n#\n#\n# Example 1:\n#\n#\n# Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA =\n# 2, skipB = 3\n# Output: Intersected at '8'\n# Explanation: The intersected node's value is 8 (note that this must not be 0\n# if the two lists intersect).\n# From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as\n# [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are\n# 3 nodes before the intersected node in B.\n# - Note that the intersected node's value is not 1 because the nodes with\n# value 1 in A and B (2^nd node in A and 3^rd node in B) are different node\n# references. In other words, they point to two different locations in memory,\n# while the nodes with value 8 in A and B (3^rd node in A and 4^th node in B)\n# point to the same location in memory.\n#\n#\n# Example 2:\n#\n#\n# Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3,\n# skipB = 1\n# Output: Intersected at '2'\n# Explanation: The intersected node's value is 2 (note that this must not be 0\n# if the two lists intersect).\n# From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as\n# [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node\n# before the intersected node in B.\n#\n#\n# Example 3:\n#\n#\n# Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n# Output: No intersection\n# Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it\n# reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0,\n# while skipA and skipB can be arbitrary values.\n# Explanation: The two lists do not intersect, so return null.\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes of listA is in the m.\n# The number of nodes of listB is in the n.\n# 1 &lt;= m, n &lt;= 3 * 10^4\n# 1 &lt;= Node.val &lt;= 10^5\n# 0 &lt;= skipA &lt;\u00a0m\n# 0 &lt;= skipB &lt;\u00a0n\n# intersectVal is 0 if listA and listB do not intersect.\n# intersectVal == listA[skipA] == listB[skipB] if listA and listB\n# intersect.\n#\n#\n#\n# Follow up: Could you write a solution that runs in O(m + n) time and use only\n# O(1) memory?\n#\n\n# @lc code=start\n# Definition for singly-linked list.\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n\n        # Stack solution:\n\n        # a = []\n        # b = []\n\n        # while headA or headB:\n\n        #     if headA:\n        #         a.append(headA)\n        #         headA = headA.next\n\n        #     if headB:\n        #         b.append(headB)\n        #         headB = headB.next\n\n        # x = None\n        # for _ in range(min(len(a), len(b))):\n        #     i = a.pop()\n        #     j = b.pop()\n\n        #     if i != j:\n        #         break\n\n        #     x = i\n\n        # return x\n\n        # solution 2:\n\n        lA = lB = 0\n\n        a, b = headA, headB\n\n        while a:\n            lA += 1\n            a = a.next\n\n        while b:\n            lB += 1\n            b = b.next\n\n        for _ in range(abs(lA-lB)):\n            if lA &gt; lB:\n                headA = headA.next\n            else:\n                headB = headB.next\n\n        while headA:\n\n            if headA == headB:\n                return headA\n\n            headA = headA.next\n            headB = headB.next\n\n        return\n\n# @lc code=end\n</code></pre>","tags":["Hash Table","Linked List","Two Pointers"]},{"location":"165.compare-version-numbers/","title":"165. Compare Version Numbers","text":"<p>Problem Page: https://leetcode.com/problems/compare-version-numbers/</p> <pre><code>#\n# @lc app=leetcode id=165 lang=python3\n#\n# [165] Compare Version Numbers\n#\n# https://leetcode.com/problems/compare-version-numbers/description/\n#\n# algorithms\n# Medium (35.75%)\n# Likes:    1912\n# Dislikes: 2432\n# Total Accepted:    348.5K\n# Total Submissions: 974.2K\n# Testcase Example:  '\"1.01\"\\n\"1.001\"'\n#\n# Given two version numbers,\u00a0version1 and version2, compare them.\n#\n#\n#\n#\n# Version numbers consist of one or more revisions joined by a dot\u00a0'.'. Each\n# revision\u00a0consists of digits\u00a0and may contain leading zeros. Every revision\n# contains at least one character. Revisions are 0-indexed from left to right,\n# with the leftmost revision being revision 0, the next revision being revision\n# 1, and so on. For example\u00a02.5.33\u00a0and\u00a00.1\u00a0are valid version numbers.\n#\n# To compare version numbers, compare their revisions in left-to-right order.\n# Revisions are compared using their\u00a0integer value ignoring any leading zeros.\n# This means that revisions\u00a01\u00a0and\u00a0001\u00a0are considered\u00a0equal. If a version number\n# does not specify a revision at an index, then\u00a0treat the revision as\u00a00. For\n# example, version\u00a01.0 is less than version\u00a01.1\u00a0because their revision 0s are\n# the same, but their revision 1s are\u00a00\u00a0and\u00a01\u00a0respectively, and\u00a00 &lt; 1.\n#\n# Return the following:\n#\n#\n# If version1 &lt; version2, return -1.\n# If version1 &gt; version2, return 1.\n# Otherwise, return 0.\n#\n#\n#\n# Example 1:\n#\n#\n# Input: version1 = \"1.01\", version2 = \"1.001\"\n# Output: 0\n# Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same\n# integer \"1\".\n#\n#\n# Example 2:\n#\n#\n# Input: version1 = \"1.0\", version2 = \"1.0.0\"\n# Output: 0\n# Explanation: version1 does not specify revision 2, which means it is treated\n# as \"0\".\n#\n#\n# Example 3:\n#\n#\n# Input: version1 = \"0.1\", version2 = \"1.1\"\n# Output: -1\n# Explanation: version1's revision 0 is \"0\", while version2's revision 0 is\n# \"1\". 0 &lt; 1, so version1 &lt; version2.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= version1.length, version2.length &lt;= 500\n# version1 and version2\u00a0only contain digits and '.'.\n# version1 and version2\u00a0are valid version numbers.\n# All the given revisions in\u00a0version1 and version2\u00a0can be stored in\u00a0a\u00a032-bit\n# integer.\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -&gt; int:\n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n\n        l = max(len(v1), len(v2))\n        v1 += [0] * (l-len(v1))\n        v2 += [0] * (l-len(v2))\n\n        for a, b in zip(v1, v2):\n            if a &gt; b:\n                return 1\n            elif a &lt; b:\n                return -1\n\n        return 0\n\n# @lc code=end\n</code></pre>","tags":["Two Pointers","String"]},{"location":"19.remove-nth-node-from-end-of-list/","title":"19. Remove Nth Node From End of List","text":"<p>Problem Page: https://leetcode.com/problems/remove-nth-node-from-end-of-list/</p> <pre><code>#\n# @lc app=leetcode id=19 lang=python3\n#\n# [19] Remove Nth Node From End of List\n#\n# https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/\n#\n# algorithms\n# Medium (41.18%)\n# Likes:    17192\n# Dislikes: 706\n# Total Accepted:    2.2M\n# Total Submissions: 5.2M\n# Testcase Example:  '[1,2,3,4,5]\\n2'\n#\n# Given the head of a linked list, remove the n^th node from the end of the\n# list and return its head.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [1,2,3,4,5], n = 2\n# Output: [1,2,3,5]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [1], n = 1\n# Output: []\n#\n#\n# Example 3:\n#\n#\n# Input: head = [1,2], n = 1\n# Output: [1]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is sz.\n# 1 &lt;= sz &lt;= 30\n# 0 &lt;= Node.val &lt;= 100\n# 1 &lt;= n &lt;= sz\n#\n#\n#\n# Follow up: Could you do this in one pass?\n#\n#\n\n# @lc code=start\n# Definition for singly-linked list.\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n        d = ListNode(-1, next=head)\n\n        f = s = d\n\n        # c = 0\n        # while f:\n\n        #     if c &lt;= n:\n        #         c += 1\n        #     else:\n        #         s = s.next\n\n        #     f = f.next\n\n        for _ in range(n+1):\n            f = f.next\n\n        while f:\n            s = s.next\n            f = f.next\n\n        s.next = s.next.next\n\n        return d.next\n\n\n# @lc code=end\n</code></pre>","tags":["Linked List","Two Pointers"]},{"location":"2.add-two-numbers/","title":"2. Add Two Numbers","text":"<p>Problem Page: https://leetcode.com/problems/add-two-numbers/</p> <pre><code>#\n# @lc app=leetcode id=2 lang=python3\n#\n# [2] Add Two Numbers\n#\n# https://leetcode.com/problems/add-two-numbers/description/\n#\n# algorithms\n# Medium (40.41%)\n# Likes:    25480\n# Dislikes: 4941\n# Total Accepted:    3.6M\n# Total Submissions: 8.8M\n# Testcase Example:  '[2,4,3]\\n[5,6,4]'\n#\n# You are given two non-empty linked lists representing two non-negative\n# integers. The digits are stored in reverse order, and each of their nodes\n# contains a single digit. Add the two numbers and return the sum\u00a0as a linked\n# list.\n#\n# You may assume the two numbers do not contain any leading zero, except the\n# number 0 itself.\n#\n#\n# Example 1:\n#\n#\n# Input: l1 = [2,4,3], l2 = [5,6,4]\n# Output: [7,0,8]\n# Explanation: 342 + 465 = 807.\n#\n#\n# Example 2:\n#\n#\n# Input: l1 = [0], l2 = [0]\n# Output: [0]\n#\n#\n# Example 3:\n#\n#\n# Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# Output: [8,9,9,9,0,0,0,1]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in each linked list is in the range [1, 100].\n# 0 &lt;= Node.val &lt;= 9\n# It is guaranteed that the list represents a number that does not have leading\n# zeros.\n#\n#\n#\n\n# @lc code=start\n\n# Definition for singly-linked list.\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        c = 0\n        head = node = None\n        while l1 or l2 or c:\n\n            x = c\n\n            if l1:\n                x += l1.val\n                l1 = l1.next\n\n            if l2:\n                x += l2.val\n                l2 = l2.next\n\n            if not head:\n                head = node = ListNode(x % 10)\n            else:\n                node.next = ListNode(x % 10)\n                node = node.next\n\n            c = x // 10\n\n        return head\n\n\n# @lc code=end\n</code></pre>","tags":["Linked List","Math","Recursion"]},{"location":"20.valid-parentheses/","title":"20. Valid Parentheses","text":"<p>Problem Page: https://leetcode.com/problems/valid-parentheses/</p> <pre><code>#\n# @lc app=leetcode id=20 lang=python3\n#\n# [20] Valid Parentheses\n#\n# https://leetcode.com/problems/valid-parentheses/description/\n#\n# algorithms\n# Easy (40.48%)\n# Likes:    22116\n# Dislikes: 1482\n# Total Accepted:    3.8M\n# Total Submissions: 9.4M\n# Testcase Example:  '\"()\"'\n#\n# Given a string s containing just the characters '(', ')', '{', '}', '[' and\n# ']', determine if the input string is valid.\n#\n# An input string is valid if:\n#\n#\n# Open brackets must be closed by the same type of brackets.\n# Open brackets must be closed in the correct order.\n# Every close bracket has a corresponding open bracket of the same type.\n#\n#\n#\n# Example 1:\n#\n#\n# Input: s = \"()\"\n# Output: true\n#\n#\n# Example 2:\n#\n#\n# Input: s = \"()[]{}\"\n# Output: true\n#\n#\n# Example 3:\n#\n#\n# Input: s = \"(]\"\n# Output: false\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= s.length &lt;= 10^4\n# s consists of parentheses only '()[]{}'.\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def isValid(self, s: str) -&gt; bool:\n\n        x = []\n\n        for i in s:\n            if i == '(':\n                x.append(i)\n            elif i == '[':\n                x.append(i)\n            elif i == '{':\n                x.append(i)\n            elif i == ')' and (not len(x) or x.pop() != '('):\n                return False\n            elif i == ']' and (not len(x) or x.pop() != '['):\n                return False\n            elif i == '}' and (not len(x) or x.pop() != '{'):\n                return False\n\n        return False if len(x) else True\n\n# @lc code=end\n</code></pre>","tags":["String","Stack"]},{"location":"202.happy-number/","title":"202. Happy Number","text":"<p>Problem Page: https://leetcode.com/problems/happy-number/</p> <pre><code>#\n# @lc app=leetcode id=202 lang=python3\n#\n# [202] Happy Number\n#\n# https://leetcode.com/problems/happy-number/description/\n#\n# algorithms\n# Easy (54.87%)\n# Likes:    9544\n# Dislikes: 1258\n# Total Accepted:    1.3M\n# Total Submissions: 2.3M\n# Testcase Example:  '19'\n#\n# Write an algorithm to determine if a number n is happy.\n#\n# A happy number is a number defined by the following process:\n#\n#\n# Starting with any positive integer, replace the number by the sum of the\n# squares of its digits.\n# Repeat the process until the number equals 1 (where it will stay), or it\n# loops endlessly in a cycle which does not include 1.\n# Those numbers for which this process ends in 1 are happy.\n#\n#\n# Return true if n is a happy number, and false if not.\n#\n#\n# Example 1:\n#\n#\n# Input: n = 19\n# Output: true\n# Explanation:\n# 1^2 + 9^2 = 82\n# 8^2 + 2^2 = 68\n# 6^2 + 8^2 = 100\n# 1^2 + 0^2 + 0^2 = 1\n#\n#\n# Example 2:\n#\n#\n# Input: n = 2\n# Output: false\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= n &lt;= 2^31 - 1\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n\n    def isHappy(self, n: int) -&gt; bool:\n\n        s = set()\n\n        while n not in s:\n            s.add(n)\n            if n == 1:\n                return True\n            n = self.fn(n)\n\n        return False\n\n    @staticmethod\n    def fn(x: int):\n        t = 0\n        while x &gt; 0:\n            m = x % 10\n            t += m*m\n            x //= 10\n        return t\n# @lc code=end\n</code></pre>","tags":["Hash Table","Math","Two Pointers"]},{"location":"203.remove-linked-list-elements/","title":"203. Remove Linked List Elements","text":"<p>Problem Page: https://leetcode.com/problems/remove-linked-list-elements/</p> <pre><code>#\n# @lc app=leetcode id=203 lang=python3\n#\n# [203] Remove Linked List Elements\n#\n# https://leetcode.com/problems/remove-linked-list-elements/description/\n#\n# algorithms\n# Easy (46.10%)\n# Likes:    7779\n# Dislikes: 217\n# Total Accepted:    1M\n# Total Submissions: 2.1M\n# Testcase Example:  '[1,2,6,3,4,5,6]\\n6'\n#\n# Given the head of a linked list and an integer val, remove all the nodes of\n# the linked list that has Node.val == val, and return the new head.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [1,2,6,3,4,5,6], val = 6\n# Output: [1,2,3,4,5]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [], val = 1\n# Output: []\n#\n#\n# Example 3:\n#\n#\n# Input: head = [7,7,7,7], val = 7\n# Output: []\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is in the range [0, 10^4].\n# 1 &lt;= Node.val &lt;= 50\n# 0 &lt;= val &lt;= 50\n#\n#\n#\n\n# @lc code=start\n# Definition for singly-linked list.\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n\n        d = ListNode(next=head)\n\n        c = d\n        while c.next:\n\n            if c.next.val == val:\n                c.next = c.next.next\n            else:\n                c = c.next\n\n        return d.next\n\n# @lc code=end\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"206.reverse-linked-list/","title":"206. Reverse Linked List","text":"<p>Problem Page: https://leetcode.com/problems/reverse-linked-list/</p> <pre><code>#\n# @lc app=leetcode id=206 lang=python3\n#\n# [206] Reverse Linked List\n#\n# https://leetcode.com/problems/reverse-linked-list/description/\n#\n# algorithms\n# Easy (73.66%)\n# Likes:    19643\n# Dislikes: 357\n# Total Accepted:    3.4M\n# Total Submissions: 4.6M\n# Testcase Example:  '[1,2,3,4,5]'\n#\n# Given the head of a singly linked list, reverse the list, and return the\n# reversed list.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [1,2,3,4,5]\n# Output: [5,4,3,2,1]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [1,2]\n# Output: [2,1]\n#\n#\n# Example 3:\n#\n#\n# Input: head = []\n# Output: []\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is the range [0, 5000].\n# -5000 &lt;= Node.val &lt;= 5000\n#\n#\n#\n# Follow up: A linked list can be reversed either iteratively or recursively.\n# Could you implement both?\n#\n#\n\n# @lc code=start\n# Definition for singly-linked list.\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        pre = None\n        cur = head\n\n        while cur:\n            tmp = cur\n            cur = cur.next\n\n            tmp.next = pre\n            pre = tmp\n\n        return pre\n\n# @lc code=end\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"209.minimum-size-subarray-sum/","title":"209. Minimum Size Subarray Sum","text":"<p>Problem Page: https://leetcode.com/problems/minimum-size-subarray-sum/</p> <pre><code>#\n# @lc app=leetcode id=209 lang=python3\n#\n# [209] Minimum Size Subarray Sum\n#\n# https://leetcode.com/problems/minimum-size-subarray-sum/description/\n#\n# algorithms\n# Medium (45.03%)\n# Likes:    11653\n# Dislikes: 338\n# Total Accepted:    847.8K\n# Total Submissions: 1.8M\n# Testcase Example:  '7\\n[2,3,1,2,4,3]'\n#\n# Given an array of positive integers nums and a positive integer target,\n# return the minimal length of a subarray whose sum is greater than or equal to\n# target. If there is no such subarray, return 0 instead.\n#\n#\n# Example 1:\n#\n#\n# Input: target = 7, nums = [2,3,1,2,4,3]\n# Output: 2\n# Explanation: The subarray [4,3] has the minimal length under the problem\n# constraint.\n#\n#\n# Example 2:\n#\n#\n# Input: target = 4, nums = [1,4,4]\n# Output: 1\n#\n#\n# Example 3:\n#\n#\n# Input: target = 11, nums = [1,1,1,1,1,1,1,1]\n# Output: 0\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= target &lt;= 10^9\n# 1 &lt;= nums.length &lt;= 10^5\n# 1 &lt;= nums[i] &lt;= 10^4\n#\n#\n#\n# Follow up: If you have figured out the O(n) solution, try coding another\n# solution of which the time complexity is O(n log(n)).\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:\n        # l = len(nums)\n        # res = float('inf')\n        # for i in range(l):\n        #     s = 0\n        #     for j in range(i, l):\n        #         s += nums[j]\n        #         if s &gt;= target:\n        #             res = min(j-i+1, res)\n        #             break\n        # return res if res != float('inf') else 0\n\n        # i = j = 0\n        # res = float('inf')\n\n        # s = nums[0]\n        # while i &lt;= j &lt; len(nums):\n        #     if s &gt;= target:\n        #         res = min(j-i+1, res)\n        #         s -= nums[i]\n        #         i += 1\n        #     else:\n        #         j += 1\n        #         s += nums[j] if j &lt; len(nums) else 0\n\n        # return res if res != float('inf') else 0\n\n        i = j = 0\n        res = float('inf')\n\n        s = 0\n        while j &lt; len(nums):\n\n            s += nums[j]\n\n            while s &gt;= target:\n                res = min(j-i+1, res)\n                s -= nums[i]\n                i += 1\n\n            j += 1\n\n        return res if res != float('inf') else 0\n\n\n# @lc code=end\n</code></pre>","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"242.valid-anagram/","title":"242. Valid Anagram","text":"<p>Problem Page: https://leetcode.com/problems/valid-anagram/</p> <pre><code>#\n# @lc app=leetcode id=242 lang=python3\n#\n# [242] Valid Anagram\n#\n# https://leetcode.com/problems/valid-anagram/description/\n#\n# algorithms\n# Easy (63.08%)\n# Likes:    10622\n# Dislikes: 331\n# Total Accepted:    2.6M\n# Total Submissions: 4.2M\n# Testcase Example:  '\"anagram\"\\n\"nagaram\"'\n#\n# Given two strings s and t, return true if t is an anagram of s, and false\n# otherwise.\n#\n# An Anagram is a word or phrase formed by rearranging the letters of a\n# different word or phrase, typically using all the original letters exactly\n# once.\n#\n#\n# Example 1:\n# Input: s = \"anagram\", t = \"nagaram\"\n# Output: true\n# Example 2:\n# Input: s = \"rat\", t = \"car\"\n# Output: false\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= s.length, t.length &lt;= 5 * 10^4\n# s and t consist of lowercase English letters.\n#\n#\n#\n# Follow up: What if the inputs contain Unicode characters? How would you adapt\n# your solution to such a case?\n#\n#\n\n# @lc code=start\nclass Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n\n        # sort lists:\n\n        # return sorted(s) == sorted(t)\n\n        m = {}\n\n        for i in s:\n            m.setdefault(i, 0)\n            m[i] += 1\n\n        for i in t:\n            m.setdefault(i, 0)\n            m[i] -= 1\n\n        for i in m.values():\n            if i != 0:\n                return False\n\n        return True\n\n# @lc code=end\n</code></pre>","tags":["Hash Table","String","Sorting"]},{"location":"27.remove-element/","title":"27. Remove Element","text":"<p>Problem Page: https://leetcode.com/problems/remove-element/</p> <pre><code>#\n# @lc app=leetcode id=27 lang=python3\n#\n# [27] Remove Element\n#\n# https://leetcode.com/problems/remove-element/description/\n#\n# algorithms\n# Easy (53.10%)\n# Likes:    1201\n# Dislikes: 1594\n# Total Accepted:    2.1M\n# Total Submissions: 3.9M\n# Testcase Example:  '[3,2,2,3]\\n3'\n#\n# Given an integer array nums and an integer val, remove all occurrences of val\n# in nums in-place. The order of the elements may be changed. Then return the\n# number of elements in nums which are not equal to val.\n#\n# Consider the number of elements in nums which are not equal to val be k, to\n# get accepted, you need to do the following things:\n#\n#\n# Change the array nums such that the first k elements of nums contain the\n# elements which are not equal to val. The remaining elements of nums are not\n# important as well as the size of nums.\n# Return k.\n#\n#\n# Custom Judge:\n#\n# The judge will test your solution with the following code:\n#\n#\n# int[] nums = [...]; // Input array\n# int val = ...; // Value to remove\n# int[] expectedNums = [...]; // The expected answer with correct length.\n# \u2060                           // It is sorted with no values equaling val.\n#\n# int k = removeElement(nums, val); // Calls your implementation\n#\n# assert k == expectedNums.length;\n# sort(nums, 0, k); // Sort the first k elements of nums\n# for (int i = 0; i &lt; actualLength; i++) {\n# \u2060   assert nums[i] == expectedNums[i];\n# }\n#\n#\n# If all assertions pass, then your solution will be accepted.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [3,2,2,3], val = 3\n# Output: 2, nums = [2,2,_,_]\n# Explanation: Your function should return k = 2, with the first two elements\n# of nums being 2.\n# It does not matter what you leave beyond the returned k (hence they are\n# underscores).\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [0,1,2,2,3,0,4,2], val = 2\n# Output: 5, nums = [0,1,4,0,3,_,_,_]\n# Explanation: Your function should return k = 5, with the first five elements\n# of nums containing 0, 0, 1, 3, and 4.\n# Note that the five elements can be returned in any order.\n# It does not matter what you leave beyond the returned k (hence they are\n# underscores).\n#\n#\n#\n# Constraints:\n#\n#\n# 0 &lt;= nums.length &lt;= 100\n# 0 &lt;= nums[i] &lt;= 50\n# 0 &lt;= val &lt;= 100\n#\n#\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -&gt; int:\n        s = 0\n\n        l = len(nums)\n\n        for f in range(l):\n            if nums[f] != val:\n                nums[s] = nums[f]\n                s += 1\n\n        return s\n\n# @lc code=end\n</code></pre>","tags":["Array","Two Pointers"]},{"location":"349.intersection-of-two-arrays/","title":"349. Intersection of Two Arrays","text":"<p>Problem Page: https://leetcode.com/problems/intersection-of-two-arrays/</p> <pre><code>#\n# @lc app=leetcode id=349 lang=python3\n#\n# [349] Intersection of Two Arrays\n#\n# https://leetcode.com/problems/intersection-of-two-arrays/description/\n#\n# algorithms\n# Easy (70.98%)\n# Likes:    5261\n# Dislikes: 2189\n# Total Accepted:    923.3K\n# Total Submissions: 1.3M\n# Testcase Example:  '[1,2,2,1]\\n[2,2]'\n#\n# Given two integer arrays nums1 and nums2, return an array of their\n# intersection. Each element in the result must be unique and you may return\n# the result in any order.\n#\n#\n# Example 1:\n#\n#\n# Input: nums1 = [1,2,2,1], nums2 = [2,2]\n# Output: [2]\n#\n#\n# Example 2:\n#\n#\n# Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n# Output: [9,4]\n# Explanation: [4,9] is also accepted.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= nums1.length, nums2.length &lt;= 1000\n# 0 &lt;= nums1[i], nums2[i] &lt;= 1000\n#\n#\n#\n\n# @lc code=start\nfrom typing import List\n\n\nclass Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n\n        # # Set solution:\n\n        # s1 = set(nums1)\n        # s2 = set(nums2)\n\n        # return list(s1 &amp; s2)\n\n        # Array solution:\n\n        size = 1001\n\n        a1 = [0] * size\n        a2 = [0] * size\n\n        for i in nums1:\n            a1[i] = 1\n\n        for i in nums2:\n            a2[i] = 1\n\n        res = []\n        for i in range(size):\n            if a1[i]*a2[i] &gt; 0:\n                res.append(i)\n\n        return res\n\n# @lc code=end\n</code></pre>","tags":["Array","Hash Table","Two Pointers","Binary Search","Sorting"]},{"location":"383.ransom-note/","title":"383. Ransom Note","text":"<p>Problem Page: https://leetcode.com/problems/ransom-note/</p> <pre><code>#\n# @lc app=leetcode id=383 lang=python3\n#\n# [383] Ransom Note\n#\n# https://leetcode.com/problems/ransom-note/description/\n#\n# algorithms\n# Easy (58.33%)\n# Likes:    4532\n# Dislikes: 459\n# Total Accepted:    898.7K\n# Total Submissions: 1.5M\n# Testcase Example:  '\"a\"\\n\"b\"'\n#\n# Given two strings ransomNote and magazine, return true if ransomNote can be\n# constructed by using the letters from magazine and false otherwise.\n#\n# Each letter in magazine can only be used once in ransomNote.\n#\n#\n# Example 1:\n# Input: ransomNote = \"a\", magazine = \"b\"\n# Output: false\n# Example 2:\n# Input: ransomNote = \"aa\", magazine = \"ab\"\n# Output: false\n# Example 3:\n# Input: ransomNote = \"aa\", magazine = \"aab\"\n# Output: true\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= ransomNote.length, magazine.length &lt;= 10^5\n# ransomNote and magazine consist of lowercase English letters.\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:\n        # # Hash table solution:\n\n        # from collections import defaultdict\n\n        # m = defaultdict(int)\n\n        # for i in magazine:\n        #     m[i] += 1\n\n        # for i in ransomNote:\n        #     v = m.get(i, 0)\n        #     if v &lt;= 0:\n        #         return False\n        #     m[i] -= 1\n\n        # return True\n\n        # Array sln:\n\n        a = [0] * 26\n\n        for i in magazine:\n            a[ord(i)-ord('a')] += 1\n\n        for i in ransomNote:\n            v = a[ord(i)-ord('a')]\n            if v &lt;= 0:\n                return False\n            a[ord(i)-ord('a')] -= 1\n\n        return True\n\n# @lc code=end\n</code></pre>","tags":["Hash Table","String","Counting"]},{"location":"454.4-sum-ii/","title":"454. 4Sum II","text":"<p>Problem Page: https://leetcode.com/problems/4sum-ii/</p> <pre><code>#\n# @lc app=leetcode id=454 lang=python3\n#\n# [454] 4Sum II\n#\n# https://leetcode.com/problems/4sum-ii/description/\n#\n# algorithms\n# Medium (57.19%)\n# Likes:    4755\n# Dislikes: 135\n# Total Accepted:    306.2K\n# Total Submissions: 536K\n# Testcase Example:  '[1,2]\\n[-2,-1]\\n[-1,2]\\n[0,2]'\n#\n# Given four integer arrays nums1, nums2, nums3, and nums4 all of length n,\n# return the number of tuples (i, j, k, l) such that:\n#\n#\n# 0 &lt;= i, j, k, l &lt; n\n# nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n#\n#\n#\n# Example 1:\n#\n#\n# Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n# Output: 2\n# Explanation:\n# The two tuples are:\n# 1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) +\n# (-1) + 2 = 0\n# 2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) +\n# (-1) + 0 = 0\n#\n#\n# Example 2:\n#\n#\n# Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n# Output: 1\n#\n#\n#\n# Constraints:\n#\n#\n# n == nums1.length\n# n == nums2.length\n# n == nums3.length\n# n == nums4.length\n# 1 &lt;= n &lt;= 200\n# -2^28 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^28\n#\n#\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:\n\n        # # Brute solution: (time exceeded)\n        #\n        # c = 0\n        # for ki, vi in enumerate(nums1):\n        #     for kj, vj in enumerate(nums2):\n        #         for km, vm in enumerate(nums3):\n        #             for kn, vn in enumerate(nums4):\n        #                 if vi + vj + vm + vn == 0:\n        #                     c += 1\n        # return c\n\n        from collections import defaultdict\n\n        c = 0\n\n        ma = defaultdict(int)\n        # mb = defaultdict(int)\n\n        for i in nums1:\n            for j in nums2:\n                ma[i + j] += 1\n\n        for i in nums3:\n            for j in nums4:\n                if -(i+j) in ma:\n                    c += ma[-(i+j)]\n\n        return c\n\n\n# @lc code=end\n</code></pre>","tags":["Array","Hash Table"]},{"location":"461.hamming-distance/","title":"461. Hamming Distance","text":"<p>Problem Page: https://leetcode.com/problems/hamming-distance/</p> <pre><code>#\n# @lc app=leetcode id=461 lang=python3\n#\n# [461] Hamming Distance\n#\n# https://leetcode.com/problems/hamming-distance/description/\n#\n# algorithms\n# Easy (75.01%)\n# Likes:    3706\n# Dislikes: 213\n# Total Accepted:    542.1K\n# Total Submissions: 721.4K\n# Testcase Example:  '1\\n4'\n#\n# The Hamming distance between two integers is the number of positions at which\n# the corresponding bits are different.\n#\n# Given two integers x and y, return the Hamming distance between them.\n#\n#\n# Example 1:\n#\n#\n# Input: x = 1, y = 4\n# Output: 2\n# Explanation:\n# 1   (0 0 0 1)\n# 4   (0 1 0 0)\n# \u2060      \u2191   \u2191\n# The above arrows point to positions where the corresponding bits are\n# different.\n#\n#\n# Example 2:\n#\n#\n# Input: x = 3, y = 1\n# Output: 1\n#\n#\n#\n# Constraints:\n#\n#\n# 0 &lt;=\u00a0x, y &lt;= 2^31 - 1\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -&gt; int:\n\n        r = 0\n\n        while x or y:\n\n            x, a = divmod(x, 2)\n            y, b = divmod(y, 2)\n\n            if a != b:\n                r += 1\n\n        return r\n\n# @lc code=end\n</code></pre>","tags":["Bit Manipulation"]},{"location":"476.number-complement/","title":"476. Number Complement","text":"<p>Problem Page: https://leetcode.com/problems/number-complement/</p> <pre><code>#\n# @lc app=leetcode id=476 lang=python3\n#\n# [476] Number Complement\n#\n# https://leetcode.com/problems/number-complement/description/\n#\n# algorithms\n# Easy (67.36%)\n# Likes:    2569\n# Dislikes: 118\n# Total Accepted:    310.5K\n# Total Submissions: 459.9K\n# Testcase Example:  '5'\n#\n# The complement of an integer is the integer you get when you flip all the 0's\n# to 1's and all the 1's to 0's in its binary representation.\n#\n#\n# For example, The integer 5 is \"101\" in binary and its complement is \"010\"\n# which is the integer 2.\n#\n#\n# Given an integer num, return its complement.\n#\n#\n# Example 1:\n#\n#\n# Input: num = 5\n# Output: 2\n# Explanation: The binary representation of 5 is 101 (no leading zero bits),\n# and its complement is 010. So you need to output 2.\n#\n#\n# Example 2:\n#\n#\n# Input: num = 1\n# Output: 0\n# Explanation: The binary representation of 1 is 1 (no leading zero bits), and\n# its complement is 0. So you need to output 0.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= num &lt; 2^31\n#\n#\n#\n# Note: This question is the same as 1009:\n# https://leetcode.com/problems/complement-of-base-10-integer/\n#\n#\n\n# @lc code=start\nclass Solution:\n    def findComplement(self, num: int) -&gt; int:\n\n        r = 0\n\n        i = 0\n\n        while num:\n\n            num, x = divmod(num, 2)\n\n            r += (0 if x == 1 else 1)*2**i\n\n            i += 1\n\n        return r\n\n# @lc code=end\n</code></pre>","tags":["Bit Manipulation"]},{"location":"482.license-key-formatting/","title":"482. License Key Formatting","text":"<p>Problem Page: https://leetcode.com/problems/license-key-formatting/</p> <pre><code>#\n# @lc app=leetcode id=482 lang=python3\n#\n# [482] License Key Formatting\n#\n# https://leetcode.com/problems/license-key-formatting/description/\n#\n# algorithms\n# Easy (43.31%)\n# Likes:    1032\n# Dislikes: 1353\n# Total Accepted:    260.6K\n# Total Submissions: 600.6K\n# Testcase Example:  '\"5F3Z-2e-9-w\"\\n4'\n#\n# You are given a license key represented as a string s that consists of only\n# alphanumeric characters and dashes. The string is separated into n + 1 groups\n# by n dashes. You are also given an integer k.\n#\n# We want to reformat the string s such that each group contains exactly k\n# characters, except for the first group, which could be shorter than k but\n# still must contain at least one character. Furthermore, there must be a dash\n# inserted between two groups, and you should convert all lowercase letters to\n# uppercase.\n#\n# Return the reformatted license key.\n#\n#\n# Example 1:\n#\n#\n# Input: s = \"5F3Z-2e-9-w\", k = 4\n# Output: \"5F3Z-2E9W\"\n# Explanation: The string s has been split into two parts, each part has 4\n# characters.\n# Note that the two extra dashes are not needed and can be removed.\n#\n#\n# Example 2:\n#\n#\n# Input: s = \"2-5g-3-J\", k = 2\n# Output: \"2-5G-3J\"\n# Explanation: The string s has been split into three parts, each part has 2\n# characters except the first part as it could be shorter as mentioned\n# above.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= s.length &lt;= 10^5\n# s consists of English letters, digits, and dashes '-'.\n# 1 &lt;= k &lt;= 10^4\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -&gt; str:\n        r = \"\"\n\n        n = 0\n        for i in range(-1, -len(s)-1, -1):\n            c = s[i].upper()\n\n            if n % k == 0 and \\\n                    n != 0 and r[0] != '-':\n                r = '-' + r\n\n            if c != '-':\n                r = c + r\n                n += 1\n\n        return r.strip('-')\n\n# @lc code=end\n</code></pre>","tags":["String"]},{"location":"54.spiral-matrix/","title":"54. Spiral Matrix","text":"<p>Problem Page: https://leetcode.com/problems/spiral-matrix/</p> <pre><code>#\n# @lc app=leetcode id=54 lang=python3\n#\n# [54] Spiral Matrix\n#\n# https://leetcode.com/problems/spiral-matrix/description/\n#\n# algorithms\n# Medium (45.09%)\n# Likes:    13485\n# Dislikes: 1170\n# Total Accepted:    1.2M\n# Total Submissions: 2.5M\n# Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'\n#\n# Given an m x n matrix, return all elements of the matrix in spiral order.\n#\n#\n# Example 1:\n#\n#\n# Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n# Output: [1,2,3,6,9,8,7,4,5]\n#\n#\n# Example 2:\n#\n#\n# Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n# Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n#\n#\n#\n# Constraints:\n#\n#\n# m == matrix.length\n# n == matrix[i].length\n# 1 &lt;= m, n &lt;= 10\n# -100 &lt;= matrix[i][j] &lt;= 100\n#\n#\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:\n        m = len(matrix[0])\n        n = len(matrix)\n\n        o = 0\n\n        res = []\n\n        while m &gt; 0 and n &gt; 0:\n\n            for i in self.walk(matrix, m, n, o):\n                res.append(i)\n\n            m -= 2\n            n -= 2\n            o += 1\n\n        return res\n\n    @staticmethod\n    def walk(a, m, n, o):\n\n        x = y = 0\n\n        d = 0\n\n        loops = m*2+(n-2)*2 if m &gt; 2 and n &gt; 2 else m*n\n\n        for _ in range(loops):\n            yield a[x+o][y+o]\n\n            if d == 0:\n                if y &lt; m - 1:\n                    y += 1\n                else:\n                    d += 1\n                    x += 1\n            elif d == 1:\n                if x &lt; n - 1:\n                    x += 1\n                else:\n                    d += 1\n                    y -= 1\n            elif d == 2:\n                if y &gt; 0:\n                    y -= 1\n                else:\n                    d += 1\n                    x -= 1\n            elif d == 3:\n                x -= 1\n\n# @lc code=end\n</code></pre>","tags":["Array","Matrix","Simulation"]},{"location":"557.reverse-words-in-a-string-iii/","title":"557. Reverse Words in a String III","text":"<p>Problem Page: https://leetcode.com/problems/reverse-words-in-a-string-iii/</p> <pre><code>#\n# @lc app=leetcode id=557 lang=python3\n#\n# [557] Reverse Words in a String III\n#\n# https://leetcode.com/problems/reverse-words-in-a-string-iii/description/\n#\n# algorithms\n# Easy (81.91%)\n# Likes:    5153\n# Dislikes: 232\n# Total Accepted:    725.5K\n# Total Submissions: 884.8K\n# Testcase Example:  `\"Let's take LeetCode contest\"`\n#\n# Given a string s, reverse the order of characters in each word within a\n# sentence while still preserving whitespace and initial word order.\n#\n#\n# Example 1:\n# Input: s = \"Let's take LeetCode contest\"\n# Output: \"s'teL ekat edoCteeL tsetnoc\"\n# Example 2:\n# Input: s = \"God Ding\"\n# Output: \"doG gniD\"\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= s.length &lt;= 5 * 10^4\n# s contains printable ASCII characters.\n# s does not contain any leading or trailing spaces.\n# There is at least one word in s.\n# All the words in s are separated by a single space.\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def reverseWords(self, s: str) -&gt; str:\n\n        return ' '.join(i[::-1] for i in s.split())\n\n# @lc code=end\n</code></pre>","tags":["Two Pointers","String"]},{"location":"59.spiral-matrix-ii/","title":"59. Spiral Matrix II","text":"<p>Problem Page: https://leetcode.com/problems/spiral-matrix-ii/</p> <pre><code>#\n# @lc app=leetcode id=59 lang=python3\n#\n# [59] Spiral Matrix II\n#\n# https://leetcode.com/problems/spiral-matrix-ii/description/\n#\n# algorithms\n# Medium (67.47%)\n# Likes:    6010\n# Dislikes: 239\n# Total Accepted:    519.1K\n# Total Submissions: 740.3K\n# Testcase Example:  '3'\n#\n# Given a positive integer n, generate an n x n matrix filled with elements\n# from 1 to n^2 in spiral order.\n#\n#\n# Example 1:\n#\n#\n# Input: n = 3\n# Output: [[1,2,3],[8,9,4],[7,6,5]]\n#\n#\n# Example 2:\n#\n#\n# Input: n = 1\n# Output: [[1]]\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= n &lt;= 20\n#\n#\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n\n    def generateMatrix(self, n: int) -&gt; List[List[int]]:\n        res = [\n            [0 for _ in range(n)]\n            for _ in range(n)\n        ]\n\n        i = 1\n        offset = 0\n\n        while n &gt; 0:\n\n            i = draw(res, n, i, offset)\n\n            offset += 1\n            n -= 2\n\n        return res\n\n\ndef draw(a, n, i, offset):\n\n    if n == 1:\n        a[offset][offset] = i\n        return i+1\n\n    x = y = 0\n\n    d = 0\n\n    for _ in range(4*(n-1)):\n\n        # print(x, y, i, d)\n\n        a[offset+x][offset+y] = i\n\n        if d % 4 == 0:\n            if y &lt; n - 1:\n                y += 1\n            else:\n                d += 1\n                x += 1\n        elif d % 4 == 1:\n            if x &lt; n - 1:\n                x += 1\n            else:\n                d += 1\n                y -= 1\n        elif d % 4 == 2:\n            if y &gt; 0:\n                y -= 1\n            else:\n                d += 1\n                x -= 1\n        elif d % 4 == 3:\n            if x &gt; 1:\n                x -= 1\n\n        i += 1\n\n    return i\n\n\n# @lc code=end\n</code></pre>","tags":["Array","Matrix","Simulation"]},{"location":"67.add-binary/","title":"67. Add Binary","text":"<p>Problem Page: https://leetcode.com/problems/add-binary/</p> <pre><code>#\n# @lc app=leetcode id=67 lang=python3\n#\n# [67] Add Binary\n#\n# https://leetcode.com/problems/add-binary/description/\n#\n# algorithms\n# Easy (52.40%)\n# Likes:    8757\n# Dislikes: 870\n# Total Accepted:    1.3M\n# Total Submissions: 2.4M\n# Testcase Example:  '\"11\"\\n\"1\"'\n#\n# Given two binary strings a and b, return their sum as a binary string.\n#\n#\n# Example 1:\n# Input: a = \"11\", b = \"1\"\n# Output: \"100\"\n# Example 2:\n# Input: a = \"1010\", b = \"1011\"\n# Output: \"10101\"\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= a.length, b.length &lt;= 10^4\n# a and b consist\u00a0only of '0' or '1' characters.\n# Each string does not contain leading zeros except for the zero itself.\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def addBinary(self, a: str, b: str) -&gt; str:\n\n        # # PY WAY:\n        # return bin(int(a, 2)+int(b, 2))[2:]\n\n        r = ''\n        c = 0\n\n        i = -1\n\n        while True:\n            x = int(a[i])if -i-1 &lt; len(a) else 0\n            y = int(b[i]) if -i-1 &lt; len(b) else 0\n\n            n = x + y + c\n\n            if -i &gt; max(len(a), len(b)) and not c:\n                break\n\n            c, n = divmod(n, 2)\n\n            r = str(n) + r\n\n            i -= 1\n\n        return r\n\n# @lc code=end\n</code></pre>","tags":["Math","String","Bit Manipulation","Simulation"]},{"location":"7.reverse-integer/","title":"7. Reverse Integer","text":"<p>Problem Page: https://leetcode.com/problems/reverse-integer/</p> <pre><code>#\n# @lc app=leetcode id=7 lang=python3\n#\n# [7] Reverse Integer\n#\n# https://leetcode.com/problems/reverse-integer/description/\n#\n# algorithms\n# Medium (27.47%)\n# Likes:    11809\n# Dislikes: 12924\n# Total Accepted:    2.8M\n# Total Submissions: 10.1M\n# Testcase Example:  '123'\n#\n# Given a signed 32-bit integer x, return x with its digits reversed. If\n# reversing x causes the value to go outside the signed 32-bit integer range\n# [-2^31, 2^31 - 1], then return 0.\n#\n# Assume the environment does not allow you to store 64-bit integers (signed or\n# unsigned).\n#\n#\n# Example 1:\n#\n#\n# Input: x = 123\n# Output: 321\n#\n#\n# Example 2:\n#\n#\n# Input: x = -123\n# Output: -321\n#\n#\n# Example 3:\n#\n#\n# Input: x = 120\n# Output: 21\n#\n#\n#\n# Constraints:\n#\n#\n# -2^31 &lt;= x &lt;= 2^31 - 1\n#\n#\n#\n\n# @lc code=start\nclass Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        # # Py way:\n\n        # r = (x//abs(x) if x else 1)*int(str(abs(x))[::-1])\n\n        # return r if -2**31 &lt;= r &lt;= 2**31 - 1 else 0\n\n        # human way:\n\n        r = 0\n        s = 1 if x &gt;= 0 else -1\n        x = abs(x)\n\n        while x:\n\n            x, m = divmod(x, 10)\n\n            r = r*10+m\n\n        return s*r if -2**31 &lt;= s*r &lt;= 2**31 - 1 else 0\n\n# @lc code=end\n</code></pre>","tags":["Math"]},{"location":"704.binary-search/","title":"704. Binary Search","text":"<p>Problem Page: https://leetcode.com/problems/binary-search/</p> <pre><code>#\n# @lc app=leetcode id=704 lang=python3\n#\n# [704] Binary Search\n#\n# https://leetcode.com/problems/binary-search/description/\n#\n# algorithms\n# Easy (56.17%)\n# Likes:    10770\n# Dislikes: 215\n# Total Accepted:    2M\n# Total Submissions: 3.5M\n# Testcase Example:  '[-1,0,3,5,9,12]\\n9'\n#\n# Given an array of integers nums which is sorted in ascending order, and an\n# integer target, write a function to search target in nums. If target exists,\n# then return its index. Otherwise, return -1.\n#\n# You must write an algorithm with O(log n) runtime complexity.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [-1,0,3,5,9,12], target = 9\n# Output: 4\n# Explanation: 9 exists in nums and its index is 4\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [-1,0,3,5,9,12], target = 2\n# Output: -1\n# Explanation: 2 does not exist in nums so return -1\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= nums.length &lt;= 10^4\n# -10^4 &lt; nums[i], target &lt; 10^4\n# All the integers in nums are unique.\n# nums is sorted in ascending order.\n#\n#\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n\n        i = 0\n        j = len(nums) - 1\n\n        while i &lt;= j:\n            m = (i+j)//2\n            if nums[m] &gt; target:\n                j = m - 1\n            elif nums[m] &lt; target:\n                i = m + 1\n            else:\n                return m\n\n        return -1\n\n# @lc code=end\n</code></pre>","tags":["Array","Binary Search"]},{"location":"707.design-linked-list/","title":"707. Design Linked List","text":"<p>Problem Page: https://leetcode.com/problems/design-linked-list/</p> <pre><code>#\n# @lc app=leetcode id=707 lang=python3\n#\n# [707] Design Linked List\n#\n# https://leetcode.com/problems/design-linked-list/description/\n#\n# algorithms\n# Medium (27.67%)\n# Likes:    2416\n# Dislikes: 1520\n# Total Accepted:    283.7K\n# Total Submissions: 1M\n# Testcase Example:  '[\"MyLinkedList\",\"addAtHead\",\"addAtTail\",\"addAtIndex\",\"get\",\"deleteAtIndex\",\"get\"]\\n' +\n# '[[],[1],[3],[1,2],[1],[1],[1]]'\n#\n# Design your implementation of the linked list. You can choose to use a singly\n# or doubly linked list.\n# A node in a singly linked list should have two attributes: val and next. val\n# is the value of the current node, and next is a pointer/reference to the next\n# node.\n# If you want to use the doubly linked list, you will need one more attribute\n# prev to indicate the previous node in the linked list. Assume all nodes in\n# the linked list are 0-indexed.\n#\n# Implement the MyLinkedList class:\n#\n#\n# MyLinkedList() Initializes the MyLinkedList object.\n# int get(int index) Get the value of the index^th node in the linked list. If\n# the index is invalid, return -1.\n# void addAtHead(int val) Add a node of value val before the first element of\n# the linked list. After the insertion, the new node will be the first node of\n# the linked list.\n# void addAtTail(int val) Append a node of value val as the last element of the\n# linked list.\n# void addAtIndex(int index, int val) Add a node of value val before the\n# index^th node in the linked list. If index equals the length of the linked\n# list, the node will be appended to the end of the linked list. If index is\n# greater than the length, the node will not be inserted.\n# void deleteAtIndex(int index) Delete the index^th node in the linked list, if\n# the index is valid.\n#\n#\n#\n# Example 1:\n#\n#\n# Input\n# [\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\",\n# \"deleteAtIndex\", \"get\"]\n# [[], [1], [3], [1, 2], [1], [1], [1]]\n# Output\n# [null, null, null, null, 2, null, 3]\n#\n# Explanation\n# MyLinkedList myLinkedList = new MyLinkedList();\n# myLinkedList.addAtHead(1);\n# myLinkedList.addAtTail(3);\n# myLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3\n# myLinkedList.get(1);              // return 2\n# myLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3\n# myLinkedList.get(1);              // return 3\n#\n#\n#\n# Constraints:\n#\n#\n# 0 &lt;= index, val &lt;= 1000\n# Please do not use the built-in LinkedList library.\n# At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and\n# deleteAtIndex.\n#\n#\n#\n\n# @lc code=start\n\nclass node:\n\n    def __init__(self, val=0, next=None):\n        self.val: int = val\n        self.next: node = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n\n        self.node = node(-1)\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        h = self.node.next\n\n        for _ in range(index):\n            h = h.next\n\n        return h.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        # self.size += 1\n        # self.node.next = node(val, next=self.node.next)\n\n        self.addAtIndex(0, val)\n\n    def addAtTail(self, val: int) -&gt; None:\n        # h = self.node\n\n        # for _ in range(self.size):\n        #     h = h.next\n\n        # h.next = node(val)\n        # self.size += 1\n\n        self.addAtIndex(self.size, val)\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        h = self.node\n\n        for _ in range(index):\n            h = h.next\n\n        h.next = node(val, next=h.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        h = self.node\n\n        for _ in range(index):\n            h = h.next\n\n        h.next = h.next.next\n        self.size -= 1\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)\n# @lc code=end\n</code></pre>","tags":["Linked List","Design"]},{"location":"9.palindrome-number/","title":"9. Palindrome Number","text":"<p>Problem Page: https://leetcode.com/problems/palindrome-number/</p> <pre><code>#\n# @lc app=leetcode id=9 lang=python3\n#\n# [9] Palindrome Number\n#\n# https://leetcode.com/problems/palindrome-number/description/\n#\n# algorithms\n# Easy (53.59%)\n# Likes:    9317\n# Dislikes: 2482\n# Total Accepted:    3.1M\n# Total Submissions: 5.8M\n# Testcase Example:  '121'\n#\n# Given an integer x, return true if x is a palindrome, and false otherwise.\n#\n#\n# Example 1:\n#\n#\n# Input: x = 121\n# Output: true\n# Explanation: 121 reads as 121 from left to right and from right to left.\n#\n#\n# Example 2:\n#\n#\n# Input: x = -121\n# Output: false\n# Explanation: From left to right, it reads -121. From right to left, it\n# becomes 121-. Therefore it is not a palindrome.\n#\n#\n# Example 3:\n#\n#\n# Input: x = 10\n# Output: false\n# Explanation: Reads 01 from right to left. Therefore it is not a\n# palindrome.\n#\n#\n#\n# Constraints:\n#\n#\n# -2^31\u00a0&lt;= x &lt;= 2^31\u00a0- 1\n#\n#\n#\n# Follow up: Could you solve it without converting the integer to a string?\n#\n\n# @lc code=start\nclass Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        # the python way\n        # return str(x) == str(x)[::-1]\n\n        # Convert to string\n        #\n        # s = str(x)\n        # i = 0\n        # j = len(s) - 1\n        # while i &lt;= j:\n        #     if s[i] != s[j]:\n        #         return False\n        #     i += 1\n        #     j -= 1\n        # return True\n\n        # Math operation\n        if x &lt; 0:\n            return False\n        i = x\n        y = 0\n        while i &gt; 0:\n            y = y*10+i % 10\n            i //= 10\n        return x == y\n\n# @lc code=end\n</code></pre>","tags":["Math"]},{"location":"92.reverse-linked-list-ii/","title":"92. Reverse Linked List II","text":"<p>Problem Page: https://leetcode.com/problems/reverse-linked-list-ii/</p> <pre><code>#\n# @lc app=leetcode id=92 lang=python3\n#\n# [92] Reverse Linked List II\n#\n# https://leetcode.com/problems/reverse-linked-list-ii/description/\n#\n# algorithms\n# Medium (45.45%)\n# Likes:    10815\n# Dislikes: 497\n# Total Accepted:    751.9K\n# Total Submissions: 1.6M\n# Testcase Example:  '[1,2,3,4,5]\\n2\\n4'\n#\n# Given the head of a singly linked list and two integers left and right where\n# left &lt;= right, reverse the nodes of the list from position left to position\n# right, and return the reversed list.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [1,2,3,4,5], left = 2, right = 4\n# Output: [1,4,3,2,5]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [5], left = 1, right = 1\n# Output: [5]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is n.\n# 1 &lt;= n &lt;= 500\n# -500 &lt;= Node.val &lt;= 500\n# 1 &lt;= left &lt;= right &lt;= n\n#\n#\n#\n# Follow up: Could you do it in one pass?\n#\n\n# @lc code=start\n# Definition for singly-linked list.\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&gt; Optional[ListNode]:\n        # stack solution: O(n) / O(n)\n\n        dummy = ListNode(next=head)\n\n        s = []\n\n        i = 0\n        h = dummy\n        while h:\n\n            if left &lt;= i &lt;= right:\n                s.append(h.val)\n\n            i += 1\n            h = h.next\n\n        i = 0\n        h = dummy\n        while h:\n\n            if left &lt;= i and s:\n                h.val = s.pop()\n\n            i += 1\n            h = h.next\n\n        return dummy.next\n\n\n# @lc code=end\n</code></pre>","tags":["Linked List"]},{"location":"977.squares-of-a-sorted-array/","title":"977. Squares of a Sorted Array","text":"<p>Problem Page: https://leetcode.com/problems/squares-of-a-sorted-array/</p> <pre><code>#\n# @lc app=leetcode id=977 lang=python3\n#\n# [977] Squares of a Sorted Array\n#\n# https://leetcode.com/problems/squares-of-a-sorted-array/description/\n#\n# algorithms\n# Easy (71.89%)\n# Likes:    8325\n# Dislikes: 204\n# Total Accepted:    1.5M\n# Total Submissions: 2.1M\n# Testcase Example:  '[-4,-1,0,3,10]'\n#\n# Given an integer array nums sorted in non-decreasing order, return an array\n# of the squares of each number sorted in non-decreasing order.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [-4,-1,0,3,10]\n# Output: [0,1,9,16,100]\n# Explanation: After squaring, the array becomes [16,1,0,9,100].\n# After sorting, it becomes [0,1,9,16,100].\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [-7,-3,2,3,11]\n# Output: [4,9,9,49,121]\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= nums.length &lt;= 10^4\n# -10^4 &lt;= nums[i] &lt;= 10^4\n# nums is sorted in non-decreasing order.\n#\n#\n#\n# Follow up: Squaring each element and sorting the new array is very trivial,\n# could you find an O(n) solution using a different approach?\n#\n\n# @lc code=start\n\nfrom typing import List\n\n\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -&gt; List[int]:\n        # solution 1:\n        # return sorted((n*n for n in nums))\n\n        # solution 2:\n        i = 0\n        k = j = len(nums) - 1\n\n        res = [None for _ in nums]\n\n        while i &lt;= j:\n            x = nums[i]\n            y = nums[j]\n\n            if abs(x) &gt; abs(y):\n                res[k] = x*x\n                i += 1\n            else:\n                res[k] = y*y\n                j -= 1\n            k -= 1\n\n        return res\n\n\n# @lc code=end\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"topic-tags/","title":"Topic Tags","text":""},{"location":"topic-tags/#array","title":"Array","text":"<ul> <li>1. Two Sum</li> <li>11. Container With Most Water</li> <li>15. 3Sum</li> <li>209. Minimum Size Subarray Sum</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>454. 4Sum II</li> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> <li>704. Binary Search</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#binary-search","title":"Binary Search","text":"<ul> <li>209. Minimum Size Subarray Sum</li> <li>349. Intersection of Two Arrays</li> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#bit-manipulation","title":"Bit Manipulation","text":"<ul> <li>1009. Complement of Base 10 Integer</li> <li>461. Hamming Distance</li> <li>476. Number Complement</li> <li>67. Add Binary</li> </ul>"},{"location":"topic-tags/#counting","title":"Counting","text":"<ul> <li>383. Ransom Note</li> </ul>"},{"location":"topic-tags/#design","title":"Design","text":"<ul> <li>707. Design Linked List</li> </ul>"},{"location":"topic-tags/#greedy","title":"Greedy","text":"<ul> <li>11. Container With Most Water</li> </ul>"},{"location":"topic-tags/#hash-table","title":"Hash Table","text":"<ul> <li>1. Two Sum</li> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>202. Happy Number</li> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>383. Ransom Note</li> <li>454. 4Sum II</li> </ul>"},{"location":"topic-tags/#linked-list","title":"Linked List","text":"<ul> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>19. Remove Nth Node From End of List</li> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> <li>707. Design Linked List</li> <li>92. Reverse Linked List II</li> </ul>"},{"location":"topic-tags/#math","title":"Math","text":"<ul> <li>2. Add Two Numbers</li> <li>202. Happy Number</li> <li>67. Add Binary</li> <li>7. Reverse Integer</li> <li>9. Palindrome Number</li> </ul>"},{"location":"topic-tags/#matrix","title":"Matrix","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> </ul>"},{"location":"topic-tags/#prefix-sum","title":"Prefix Sum","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#recursion","title":"Recursion","text":"<ul> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> </ul>"},{"location":"topic-tags/#simulation","title":"Simulation","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> <li>67. Add Binary</li> </ul>"},{"location":"topic-tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#sorting","title":"Sorting","text":"<ul> <li>15. 3Sum</li> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#stack","title":"Stack","text":"<ul> <li>20. Valid Parentheses</li> </ul>"},{"location":"topic-tags/#string","title":"String","text":"<ul> <li>14. Longest Common Prefix</li> <li>165. Compare Version Numbers</li> <li>20. Valid Parentheses</li> <li>242. Valid Anagram</li> <li>383. Ransom Note</li> <li>482. License Key Formatting</li> <li>557. Reverse Words in a String III</li> <li>67. Add Binary</li> </ul>"},{"location":"topic-tags/#trie","title":"Trie","text":"<ul> <li>14. Longest Common Prefix</li> </ul>"},{"location":"topic-tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>11. Container With Most Water</li> <li>142. Linked List Cycle II</li> <li>15. 3Sum</li> <li>160. Intersection of Two Linked Lists</li> <li>165. Compare Version Numbers</li> <li>19. Remove Nth Node From End of List</li> <li>202. Happy Number</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>557. Reverse Words in a String III</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/","title":"Topic Tags","text":""},{"location":"topic-tags/#array","title":"Array","text":"<ul> <li>1. Two Sum</li> <li>11. Container With Most Water</li> <li>15. 3Sum</li> <li>209. Minimum Size Subarray Sum</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>454. 4Sum II</li> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> <li>704. Binary Search</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#binary-search","title":"Binary Search","text":"<ul> <li>209. Minimum Size Subarray Sum</li> <li>349. Intersection of Two Arrays</li> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#bit-manipulation","title":"Bit Manipulation","text":"<ul> <li>1009. Complement of Base 10 Integer</li> <li>461. Hamming Distance</li> <li>476. Number Complement</li> <li>67. Add Binary</li> </ul>"},{"location":"topic-tags/#counting","title":"Counting","text":"<ul> <li>383. Ransom Note</li> </ul>"},{"location":"topic-tags/#design","title":"Design","text":"<ul> <li>707. Design Linked List</li> </ul>"},{"location":"topic-tags/#greedy","title":"Greedy","text":"<ul> <li>11. Container With Most Water</li> </ul>"},{"location":"topic-tags/#hash-table","title":"Hash Table","text":"<ul> <li>1. Two Sum</li> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>202. Happy Number</li> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>383. Ransom Note</li> <li>454. 4Sum II</li> </ul>"},{"location":"topic-tags/#linked-list","title":"Linked List","text":"<ul> <li>142. Linked List Cycle II</li> <li>160. Intersection of Two Linked Lists</li> <li>19. Remove Nth Node From End of List</li> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> <li>707. Design Linked List</li> <li>92. Reverse Linked List II</li> </ul>"},{"location":"topic-tags/#math","title":"Math","text":"<ul> <li>2. Add Two Numbers</li> <li>202. Happy Number</li> <li>67. Add Binary</li> <li>7. Reverse Integer</li> <li>9. Palindrome Number</li> </ul>"},{"location":"topic-tags/#matrix","title":"Matrix","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> </ul>"},{"location":"topic-tags/#prefix-sum","title":"Prefix Sum","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#recursion","title":"Recursion","text":"<ul> <li>2. Add Two Numbers</li> <li>203. Remove Linked List Elements</li> <li>206. Reverse Linked List</li> </ul>"},{"location":"topic-tags/#simulation","title":"Simulation","text":"<ul> <li>54. Spiral Matrix</li> <li>59. Spiral Matrix II</li> <li>67. Add Binary</li> </ul>"},{"location":"topic-tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>209. Minimum Size Subarray Sum</li> </ul>"},{"location":"topic-tags/#sorting","title":"Sorting","text":"<ul> <li>15. 3Sum</li> <li>242. Valid Anagram</li> <li>349. Intersection of Two Arrays</li> <li>977. Squares of a Sorted Array</li> </ul>"},{"location":"topic-tags/#stack","title":"Stack","text":"<ul> <li>20. Valid Parentheses</li> </ul>"},{"location":"topic-tags/#string","title":"String","text":"<ul> <li>14. Longest Common Prefix</li> <li>165. Compare Version Numbers</li> <li>20. Valid Parentheses</li> <li>242. Valid Anagram</li> <li>383. Ransom Note</li> <li>482. License Key Formatting</li> <li>557. Reverse Words in a String III</li> <li>67. Add Binary</li> </ul>"},{"location":"topic-tags/#trie","title":"Trie","text":"<ul> <li>14. Longest Common Prefix</li> </ul>"},{"location":"topic-tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>11. Container With Most Water</li> <li>142. Linked List Cycle II</li> <li>15. 3Sum</li> <li>160. Intersection of Two Linked Lists</li> <li>165. Compare Version Numbers</li> <li>19. Remove Nth Node From End of List</li> <li>202. Happy Number</li> <li>27. Remove Element</li> <li>349. Intersection of Two Arrays</li> <li>557. Reverse Words in a String III</li> <li>977. Squares of a Sorted Array</li> </ul>"}]}