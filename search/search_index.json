{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dashboard","text":""},{"location":"#dashboard","title":"Dashboard","text":"<p>GitHub Pages: https://xjasonlyu.github.io/leetcode</p> <p>Source Code: https://github.com/xjasonlyu/leetcode</p> <p></p> <p>Some Basic Algorithms:</p> <ul> <li>Binary Search Algorithm</li> <li>Merge Sort Algorithm</li> <li>Quicksort Algorithm</li> <li>Kruskal\u2019s Algorithm</li> <li>Breadth First Search (BFS) Algorithm</li> <li>Depth First Search (DFS) Algorithm</li> </ul> <p>This site is powered by Material for MkDocs and GitHub Pages.</p>"},{"location":"1.two-sum/","title":"1. Two Sum","text":"<p>Problem Page: https://leetcode.com/problems/two-sum/</p> <pre><code>#\n# @lc app=leetcode id=1 lang=python3\n#\n# [1] Two Sum\n#\n# https://leetcode.com/problems/two-sum/description/\n#\n# algorithms\n# Easy (49.76%)\n# Likes:    45395\n# Dislikes: 1480\n# Total Accepted:    9.4M\n# Total Submissions: 19M\n# Testcase Example:  '[2,7,11,15]\\n9'\n#\n# Given an array of integers nums\u00a0and an integer target, return indices of the\n# two numbers such that they add up to target.\n#\n# You may assume that each input would have exactly one solution, and you may\n# not use the same element twice.\n#\n# You can return the answer in any order.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [2,7,11,15], target = 9\n# Output: [0,1]\n# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [3,2,4], target = 6\n# Output: [1,2]\n#\n#\n# Example 3:\n#\n#\n# Input: nums = [3,3], target = 6\n# Output: [0,1]\n#\n#\n#\n# Constraints:\n#\n#\n# 2 &lt;= nums.length &lt;= 10^4\n# -10^9 &lt;= nums[i] &lt;= 10^9\n# -10^9 &lt;= target &lt;= 10^9\n# Only one valid answer exists.\n#\n#\n#\n# Follow-up:\u00a0Can you come up with an algorithm that is less than\u00a0O(n^2)\u00a0time\n# complexity?\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n# Double for loop\n#\n# for i, m in enumerate(nums):\n#     if i+1==len(nums):\n#         return\n#     for j, n in enumerate(nums[i+1:]):\n#         if m+n == target:\n#             return i, i+j+1\n# Hash table\n#\nseen = {}\nfor i, value in enumerate(nums):\nremaining = target - nums[i]\nif remaining in seen:\nreturn [i, seen[remaining]]\nseen[value] = i\n# @lc code=end\n</code></pre>","tags":["Array","Hash Table"]},{"location":"14.longest-common-prefix/","title":"14. Longest Common Prefix","text":"<p>Problem Page: https://leetcode.com/problems/longest-common-prefix/</p> <pre><code>#\n# @lc app=leetcode id=14 lang=python3\n#\n# [14] Longest Common Prefix\n#\n# https://leetcode.com/problems/longest-common-prefix/description/\n#\n# algorithms\n# Easy (40.89%)\n# Likes:    13493\n# Dislikes: 3881\n# Total Accepted:    2.3M\n# Total Submissions: 5.7M\n# Testcase Example:  '[\"flower\",\"flow\",\"flight\"]'\n#\n# Write a function to find the longest common prefix string amongst an array of\n# strings.\n#\n# If there is no common prefix, return an empty string \"\".\n#\n#\n# Example 1:\n#\n#\n# Input: strs = [\"flower\",\"flow\",\"flight\"]\n# Output: \"fl\"\n#\n#\n# Example 2:\n#\n#\n# Input: strs = [\"dog\",\"racecar\",\"car\"]\n# Output: \"\"\n# Explanation: There is no common prefix among the input strings.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= strs.length &lt;= 200\n# 0 &lt;= strs[i].length &lt;= 200\n# strs[i] consists of only lowercase English letters.\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef longestCommonPrefix(self, strs: List[str]) -&gt; str:\n# the python way\nans = ''\nfor v in zip(*strs):\nx = v[0]\nfor i in v:\nif x != i:\nreturn ans\nans += x\nreturn ans\n# @lc code=end\n</code></pre>","tags":["String","Trie"]},{"location":"165.compare-version-numbers/","title":"165. Compare Version Numbers","text":"<p>Problem Page: https://leetcode.com/problems/compare-version-numbers/</p> <pre><code>#\n# @lc app=leetcode id=165 lang=python3\n#\n# [165] Compare Version Numbers\n#\n# https://leetcode.com/problems/compare-version-numbers/description/\n#\n# algorithms\n# Medium (35.75%)\n# Likes:    1912\n# Dislikes: 2432\n# Total Accepted:    348.5K\n# Total Submissions: 974.2K\n# Testcase Example:  '\"1.01\"\\n\"1.001\"'\n#\n# Given two version numbers,\u00a0version1 and version2, compare them.\n#\n#\n#\n#\n# Version numbers consist of one or more revisions joined by a dot\u00a0'.'. Each\n# revision\u00a0consists of digits\u00a0and may contain leading zeros. Every revision\n# contains at least one character. Revisions are 0-indexed from left to right,\n# with the leftmost revision being revision 0, the next revision being revision\n# 1, and so on. For example\u00a02.5.33\u00a0and\u00a00.1\u00a0are valid version numbers.\n#\n# To compare version numbers, compare their revisions in left-to-right order.\n# Revisions are compared using their\u00a0integer value ignoring any leading zeros.\n# This means that revisions\u00a01\u00a0and\u00a0001\u00a0are considered\u00a0equal. If a version number\n# does not specify a revision at an index, then\u00a0treat the revision as\u00a00. For\n# example, version\u00a01.0 is less than version\u00a01.1\u00a0because their revision 0s are\n# the same, but their revision 1s are\u00a00\u00a0and\u00a01\u00a0respectively, and\u00a00 &lt; 1.\n#\n# Return the following:\n#\n#\n# If version1 &lt; version2, return -1.\n# If version1 &gt; version2, return 1.\n# Otherwise, return 0.\n#\n#\n#\n# Example 1:\n#\n#\n# Input: version1 = \"1.01\", version2 = \"1.001\"\n# Output: 0\n# Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same\n# integer \"1\".\n#\n#\n# Example 2:\n#\n#\n# Input: version1 = \"1.0\", version2 = \"1.0.0\"\n# Output: 0\n# Explanation: version1 does not specify revision 2, which means it is treated\n# as \"0\".\n#\n#\n# Example 3:\n#\n#\n# Input: version1 = \"0.1\", version2 = \"1.1\"\n# Output: -1\n# Explanation: version1's revision 0 is \"0\", while version2's revision 0 is\n# \"1\". 0 &lt; 1, so version1 &lt; version2.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= version1.length, version2.length &lt;= 500\n# version1 and version2\u00a0only contain digits and '.'.\n# version1 and version2\u00a0are valid version numbers.\n# All the given revisions in\u00a0version1 and version2\u00a0can be stored in\u00a0a\u00a032-bit\n# integer.\n#\n#\n#\n# @lc code=start\nclass Solution:\ndef compareVersion(self, version1: str, version2: str) -&gt; int:\nv1 = [int(i) for i in version1.split('.')]\nv2 = [int(i) for i in version2.split('.')]\nl = max(len(v1), len(v2))\nv1 += [0] * (l-len(v1))\nv2 += [0] * (l-len(v2))\nfor a, b in zip(v1, v2):\nif a &gt; b:\nreturn 1\nelif a &lt; b:\nreturn -1\nreturn 0\n# @lc code=end\n</code></pre>","tags":["Two Pointers","String"]},{"location":"2.add-two-numbers/","title":"2. Add Two Numbers","text":"<p>Problem Page: https://leetcode.com/problems/add-two-numbers/</p> <pre><code>#\n# @lc app=leetcode id=2 lang=python3\n#\n# [2] Add Two Numbers\n#\n# https://leetcode.com/problems/add-two-numbers/description/\n#\n# algorithms\n# Medium (40.41%)\n# Likes:    25480\n# Dislikes: 4941\n# Total Accepted:    3.6M\n# Total Submissions: 8.8M\n# Testcase Example:  '[2,4,3]\\n[5,6,4]'\n#\n# You are given two non-empty linked lists representing two non-negative\n# integers. The digits are stored in reverse order, and each of their nodes\n# contains a single digit. Add the two numbers and return the sum\u00a0as a linked\n# list.\n#\n# You may assume the two numbers do not contain any leading zero, except the\n# number 0 itself.\n#\n#\n# Example 1:\n#\n#\n# Input: l1 = [2,4,3], l2 = [5,6,4]\n# Output: [7,0,8]\n# Explanation: 342 + 465 = 807.\n#\n#\n# Example 2:\n#\n#\n# Input: l1 = [0], l2 = [0]\n# Output: [0]\n#\n#\n# Example 3:\n#\n#\n# Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# Output: [8,9,9,9,0,0,0,1]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in each linked list is in the range [1, 100].\n# 0 &lt;= Node.val &lt;= 9\n# It is guaranteed that the list represents a number that does not have leading\n# zeros.\n#\n#\n#\n# @lc code=start\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\nc = 0\nhead = node = None\nwhile l1 or l2 or c:\nx = c\nif l1:\nx += l1.val\nl1 = l1.next\nif l2:\nx += l2.val\nl2 = l2.next\nif not head:\nhead = node = ListNode(x % 10)\nelse:\nnode.next = ListNode(x % 10)\nnode = node.next\nc = x // 10\nreturn head\n# @lc code=end\n</code></pre>","tags":["Linked List","Math","Recursion"]},{"location":"704.binary-search/","title":"704. Binary Search","text":"<p>Problem Page: https://leetcode.com/problems/binary-search/</p> <pre><code>#\n# @lc app=leetcode id=704 lang=python3\n#\n# [704] Binary Search\n#\n# https://leetcode.com/problems/binary-search/description/\n#\n# algorithms\n# Easy (56.17%)\n# Likes:    10770\n# Dislikes: 215\n# Total Accepted:    2M\n# Total Submissions: 3.5M\n# Testcase Example:  '[-1,0,3,5,9,12]\\n9'\n#\n# Given an array of integers nums which is sorted in ascending order, and an\n# integer target, write a function to search target in nums. If target exists,\n# then return its index. Otherwise, return -1.\n#\n# You must write an algorithm with O(log n) runtime complexity.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [-1,0,3,5,9,12], target = 9\n# Output: 4\n# Explanation: 9 exists in nums and its index is 4\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [-1,0,3,5,9,12], target = 2\n# Output: -1\n# Explanation: 2 does not exist in nums so return -1\n#\n#\n#\n# Constraints:\n#\n#\n# 1 &lt;= nums.length &lt;= 10^4\n# -10^4 &lt; nums[i], target &lt; 10^4\n# All the integers in nums are unique.\n# nums is sorted in ascending order.\n#\n#\n#\n# @lc code=start\nfrom typing import List\nclass Solution:\ndef search(self, nums: List[int], target: int) -&gt; int:\ni = 0\nj = len(nums) - 1\nwhile i &lt;= j:\nm = (i+j)//2\nif nums[m] &gt; target:\nj = m - 1\nelif nums[m] &lt; target:\ni = m + 1\nelse:\nreturn m\nreturn -1\n# @lc code=end\n</code></pre>","tags":["Array","Binary Search"]},{"location":"9.palindrome-number/","title":"9. Palindrome Number","text":"<p>Problem Page: https://leetcode.com/problems/palindrome-number/</p> <pre><code>#\n# @lc app=leetcode id=9 lang=python3\n#\n# [9] Palindrome Number\n#\n# https://leetcode.com/problems/palindrome-number/description/\n#\n# algorithms\n# Easy (53.59%)\n# Likes:    9317\n# Dislikes: 2482\n# Total Accepted:    3.1M\n# Total Submissions: 5.8M\n# Testcase Example:  '121'\n#\n# Given an integer x, return true if x is a palindrome, and false otherwise.\n#\n#\n# Example 1:\n#\n#\n# Input: x = 121\n# Output: true\n# Explanation: 121 reads as 121 from left to right and from right to left.\n#\n#\n# Example 2:\n#\n#\n# Input: x = -121\n# Output: false\n# Explanation: From left to right, it reads -121. From right to left, it\n# becomes 121-. Therefore it is not a palindrome.\n#\n#\n# Example 3:\n#\n#\n# Input: x = 10\n# Output: false\n# Explanation: Reads 01 from right to left. Therefore it is not a\n# palindrome.\n#\n#\n#\n# Constraints:\n#\n#\n# -2^31\u00a0&lt;= x &lt;= 2^31\u00a0- 1\n#\n#\n#\n# Follow up: Could you solve it without converting the integer to a string?\n#\n# @lc code=start\nclass Solution:\ndef isPalindrome(self, x: int) -&gt; bool:\n# the python way\n# return str(x) == str(x)[::-1]\n# Convert to string\n#\n# s = str(x)\n# i = 0\n# j = len(s) - 1\n# while i &lt;= j:\n#     if s[i] != s[j]:\n#         return False\n#     i += 1\n#     j -= 1\n# return True\n# Math operation\nif x &lt; 0:\nreturn False\ni = x\ny = 0\nwhile i &gt; 0:\ny = y*10+i % 10\ni //= 10\nreturn x == y\n# @lc code=end\n</code></pre>","tags":["Math"]},{"location":"topic-tags/","title":"Topic Tags","text":""},{"location":"topic-tags/#array","title":"Array","text":"<ul> <li>1. Two Sum</li> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#binary-search","title":"Binary Search","text":"<ul> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#hash-table","title":"Hash Table","text":"<ul> <li>1. Two Sum</li> </ul>"},{"location":"topic-tags/#linked-list","title":"Linked List","text":"<ul> <li>2. Add Two Numbers</li> </ul>"},{"location":"topic-tags/#math","title":"Math","text":"<ul> <li>2. Add Two Numbers</li> <li>9. Palindrome Number</li> </ul>"},{"location":"topic-tags/#recursion","title":"Recursion","text":"<ul> <li>2. Add Two Numbers</li> </ul>"},{"location":"topic-tags/#string","title":"String","text":"<ul> <li>14. Longest Common Prefix</li> <li>165. Compare Version Numbers</li> </ul>"},{"location":"topic-tags/#trie","title":"Trie","text":"<ul> <li>14. Longest Common Prefix</li> </ul>"},{"location":"topic-tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>165. Compare Version Numbers</li> </ul>"},{"location":"topic-tags/","title":"Topic Tags","text":""},{"location":"topic-tags/#array","title":"Array","text":"<ul> <li>1. Two Sum</li> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#binary-search","title":"Binary Search","text":"<ul> <li>704. Binary Search</li> </ul>"},{"location":"topic-tags/#hash-table","title":"Hash Table","text":"<ul> <li>1. Two Sum</li> </ul>"},{"location":"topic-tags/#linked-list","title":"Linked List","text":"<ul> <li>2. Add Two Numbers</li> </ul>"},{"location":"topic-tags/#math","title":"Math","text":"<ul> <li>2. Add Two Numbers</li> <li>9. Palindrome Number</li> </ul>"},{"location":"topic-tags/#recursion","title":"Recursion","text":"<ul> <li>2. Add Two Numbers</li> </ul>"},{"location":"topic-tags/#string","title":"String","text":"<ul> <li>14. Longest Common Prefix</li> <li>165. Compare Version Numbers</li> </ul>"},{"location":"topic-tags/#trie","title":"Trie","text":"<ul> <li>14. Longest Common Prefix</li> </ul>"},{"location":"topic-tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>165. Compare Version Numbers</li> </ul>"}]}